// Code generated by mdatagen. DO NOT EDIT.

package metadata

import (
	"time"

	"go.opentelemetry.io/collector/component"
	"go.opentelemetry.io/collector/confmap"
	"go.opentelemetry.io/collector/pdata/pcommon"
	"go.opentelemetry.io/collector/pdata/pmetric"
	"go.opentelemetry.io/collector/receiver"
)

// MetricSettings provides common settings for a particular metric.
type MetricSettings struct {
	Enabled bool `mapstructure:"enabled"`

	enabledSetByUser bool
}

func (ms *MetricSettings) Unmarshal(parser *confmap.Conf) error {
	if parser == nil {
		return nil
	}
	err := parser.Unmarshal(ms, confmap.WithErrorUnused())
	if err != nil {
		return err
	}
	ms.enabledSetByUser = parser.IsSet("enabled")
	return nil
}

// MetricsSettings provides settings for expvarreceiver metrics.
type MetricsSettings struct {
	ProcessRuntimeMemstatsBuckHashSys   MetricSettings `mapstructure:"process.runtime.memstats.buck_hash_sys"`
	ProcessRuntimeMemstatsFrees         MetricSettings `mapstructure:"process.runtime.memstats.frees"`
	ProcessRuntimeMemstatsGcCPUFraction MetricSettings `mapstructure:"process.runtime.memstats.gc_cpu_fraction"`
	ProcessRuntimeMemstatsGcSys         MetricSettings `mapstructure:"process.runtime.memstats.gc_sys"`
	ProcessRuntimeMemstatsHeapAlloc     MetricSettings `mapstructure:"process.runtime.memstats.heap_alloc"`
	ProcessRuntimeMemstatsHeapIdle      MetricSettings `mapstructure:"process.runtime.memstats.heap_idle"`
	ProcessRuntimeMemstatsHeapInuse     MetricSettings `mapstructure:"process.runtime.memstats.heap_inuse"`
	ProcessRuntimeMemstatsHeapObjects   MetricSettings `mapstructure:"process.runtime.memstats.heap_objects"`
	ProcessRuntimeMemstatsHeapReleased  MetricSettings `mapstructure:"process.runtime.memstats.heap_released"`
	ProcessRuntimeMemstatsHeapSys       MetricSettings `mapstructure:"process.runtime.memstats.heap_sys"`
	ProcessRuntimeMemstatsLastPause     MetricSettings `mapstructure:"process.runtime.memstats.last_pause"`
	ProcessRuntimeMemstatsLookups       MetricSettings `mapstructure:"process.runtime.memstats.lookups"`
	ProcessRuntimeMemstatsMallocs       MetricSettings `mapstructure:"process.runtime.memstats.mallocs"`
	ProcessRuntimeMemstatsMcacheInuse   MetricSettings `mapstructure:"process.runtime.memstats.mcache_inuse"`
	ProcessRuntimeMemstatsMcacheSys     MetricSettings `mapstructure:"process.runtime.memstats.mcache_sys"`
	ProcessRuntimeMemstatsMspanInuse    MetricSettings `mapstructure:"process.runtime.memstats.mspan_inuse"`
	ProcessRuntimeMemstatsMspanSys      MetricSettings `mapstructure:"process.runtime.memstats.mspan_sys"`
	ProcessRuntimeMemstatsNextGc        MetricSettings `mapstructure:"process.runtime.memstats.next_gc"`
	ProcessRuntimeMemstatsNumForcedGc   MetricSettings `mapstructure:"process.runtime.memstats.num_forced_gc"`
	ProcessRuntimeMemstatsNumGc         MetricSettings `mapstructure:"process.runtime.memstats.num_gc"`
	ProcessRuntimeMemstatsOtherSys      MetricSettings `mapstructure:"process.runtime.memstats.other_sys"`
	ProcessRuntimeMemstatsPauseTotal    MetricSettings `mapstructure:"process.runtime.memstats.pause_total"`
	ProcessRuntimeMemstatsStackInuse    MetricSettings `mapstructure:"process.runtime.memstats.stack_inuse"`
	ProcessRuntimeMemstatsStackSys      MetricSettings `mapstructure:"process.runtime.memstats.stack_sys"`
	ProcessRuntimeMemstatsSys           MetricSettings `mapstructure:"process.runtime.memstats.sys"`
	ProcessRuntimeMemstatsTotalAlloc    MetricSettings `mapstructure:"process.runtime.memstats.total_alloc"`
}

func DefaultMetricsSettings() MetricsSettings {
	return MetricsSettings{
		ProcessRuntimeMemstatsBuckHashSys: MetricSettings{
			Enabled: true,
		},
		ProcessRuntimeMemstatsFrees: MetricSettings{
			Enabled: true,
		},
		ProcessRuntimeMemstatsGcCPUFraction: MetricSettings{
			Enabled: true,
		},
		ProcessRuntimeMemstatsGcSys: MetricSettings{
			Enabled: true,
		},
		ProcessRuntimeMemstatsHeapAlloc: MetricSettings{
			Enabled: true,
		},
		ProcessRuntimeMemstatsHeapIdle: MetricSettings{
			Enabled: true,
		},
		ProcessRuntimeMemstatsHeapInuse: MetricSettings{
			Enabled: true,
		},
		ProcessRuntimeMemstatsHeapObjects: MetricSettings{
			Enabled: true,
		},
		ProcessRuntimeMemstatsHeapReleased: MetricSettings{
			Enabled: true,
		},
		ProcessRuntimeMemstatsHeapSys: MetricSettings{
			Enabled: true,
		},
		ProcessRuntimeMemstatsLastPause: MetricSettings{
			Enabled: true,
		},
		ProcessRuntimeMemstatsLookups: MetricSettings{
			Enabled: false,
		},
		ProcessRuntimeMemstatsMallocs: MetricSettings{
			Enabled: true,
		},
		ProcessRuntimeMemstatsMcacheInuse: MetricSettings{
			Enabled: true,
		},
		ProcessRuntimeMemstatsMcacheSys: MetricSettings{
			Enabled: true,
		},
		ProcessRuntimeMemstatsMspanInuse: MetricSettings{
			Enabled: true,
		},
		ProcessRuntimeMemstatsMspanSys: MetricSettings{
			Enabled: true,
		},
		ProcessRuntimeMemstatsNextGc: MetricSettings{
			Enabled: true,
		},
		ProcessRuntimeMemstatsNumForcedGc: MetricSettings{
			Enabled: true,
		},
		ProcessRuntimeMemstatsNumGc: MetricSettings{
			Enabled: true,
		},
		ProcessRuntimeMemstatsOtherSys: MetricSettings{
			Enabled: true,
		},
		ProcessRuntimeMemstatsPauseTotal: MetricSettings{
			Enabled: true,
		},
		ProcessRuntimeMemstatsStackInuse: MetricSettings{
			Enabled: true,
		},
		ProcessRuntimeMemstatsStackSys: MetricSettings{
			Enabled: true,
		},
		ProcessRuntimeMemstatsSys: MetricSettings{
			Enabled: true,
		},
		ProcessRuntimeMemstatsTotalAlloc: MetricSettings{
			Enabled: false,
		},
	}
}

// ResourceAttributeSettings provides common settings for a particular metric.
type ResourceAttributeSettings struct {
	Enabled bool `mapstructure:"enabled"`
}

// ResourceAttributesSettings provides settings for expvarreceiver metrics.
type ResourceAttributesSettings struct {
}

func DefaultResourceAttributesSettings() ResourceAttributesSettings {
	return ResourceAttributesSettings{}
}

type metricProcessRuntimeMemstatsBuckHashSys struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills process.runtime.memstats.buck_hash_sys metric with initial data.
func (m *metricProcessRuntimeMemstatsBuckHashSys) init() {
	m.data.SetName("process.runtime.memstats.buck_hash_sys")
	m.data.SetDescription("Bytes of memory in profiling bucket hash tables.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricProcessRuntimeMemstatsBuckHashSys) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricProcessRuntimeMemstatsBuckHashSys) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricProcessRuntimeMemstatsBuckHashSys) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricProcessRuntimeMemstatsBuckHashSys(settings MetricSettings) metricProcessRuntimeMemstatsBuckHashSys {
	m := metricProcessRuntimeMemstatsBuckHashSys{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricProcessRuntimeMemstatsFrees struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills process.runtime.memstats.frees metric with initial data.
func (m *metricProcessRuntimeMemstatsFrees) init() {
	m.data.SetName("process.runtime.memstats.frees")
	m.data.SetDescription("Cumulative count of heap objects freed.")
	m.data.SetUnit("{objects}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricProcessRuntimeMemstatsFrees) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricProcessRuntimeMemstatsFrees) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricProcessRuntimeMemstatsFrees) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricProcessRuntimeMemstatsFrees(settings MetricSettings) metricProcessRuntimeMemstatsFrees {
	m := metricProcessRuntimeMemstatsFrees{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricProcessRuntimeMemstatsGcCPUFraction struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills process.runtime.memstats.gc_cpu_fraction metric with initial data.
func (m *metricProcessRuntimeMemstatsGcCPUFraction) init() {
	m.data.SetName("process.runtime.memstats.gc_cpu_fraction")
	m.data.SetDescription("The fraction of this program's available CPU time used by the GC since the program started.")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricProcessRuntimeMemstatsGcCPUFraction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricProcessRuntimeMemstatsGcCPUFraction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricProcessRuntimeMemstatsGcCPUFraction) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricProcessRuntimeMemstatsGcCPUFraction(settings MetricSettings) metricProcessRuntimeMemstatsGcCPUFraction {
	m := metricProcessRuntimeMemstatsGcCPUFraction{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricProcessRuntimeMemstatsGcSys struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills process.runtime.memstats.gc_sys metric with initial data.
func (m *metricProcessRuntimeMemstatsGcSys) init() {
	m.data.SetName("process.runtime.memstats.gc_sys")
	m.data.SetDescription("Bytes of memory in garbage collection metadata.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricProcessRuntimeMemstatsGcSys) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricProcessRuntimeMemstatsGcSys) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricProcessRuntimeMemstatsGcSys) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricProcessRuntimeMemstatsGcSys(settings MetricSettings) metricProcessRuntimeMemstatsGcSys {
	m := metricProcessRuntimeMemstatsGcSys{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricProcessRuntimeMemstatsHeapAlloc struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills process.runtime.memstats.heap_alloc metric with initial data.
func (m *metricProcessRuntimeMemstatsHeapAlloc) init() {
	m.data.SetName("process.runtime.memstats.heap_alloc")
	m.data.SetDescription("Bytes of allocated heap objects.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricProcessRuntimeMemstatsHeapAlloc) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricProcessRuntimeMemstatsHeapAlloc) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricProcessRuntimeMemstatsHeapAlloc) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricProcessRuntimeMemstatsHeapAlloc(settings MetricSettings) metricProcessRuntimeMemstatsHeapAlloc {
	m := metricProcessRuntimeMemstatsHeapAlloc{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricProcessRuntimeMemstatsHeapIdle struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills process.runtime.memstats.heap_idle metric with initial data.
func (m *metricProcessRuntimeMemstatsHeapIdle) init() {
	m.data.SetName("process.runtime.memstats.heap_idle")
	m.data.SetDescription("Bytes in idle (unused) spans.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricProcessRuntimeMemstatsHeapIdle) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricProcessRuntimeMemstatsHeapIdle) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricProcessRuntimeMemstatsHeapIdle) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricProcessRuntimeMemstatsHeapIdle(settings MetricSettings) metricProcessRuntimeMemstatsHeapIdle {
	m := metricProcessRuntimeMemstatsHeapIdle{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricProcessRuntimeMemstatsHeapInuse struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills process.runtime.memstats.heap_inuse metric with initial data.
func (m *metricProcessRuntimeMemstatsHeapInuse) init() {
	m.data.SetName("process.runtime.memstats.heap_inuse")
	m.data.SetDescription("Bytes in in-use spans.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricProcessRuntimeMemstatsHeapInuse) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricProcessRuntimeMemstatsHeapInuse) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricProcessRuntimeMemstatsHeapInuse) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricProcessRuntimeMemstatsHeapInuse(settings MetricSettings) metricProcessRuntimeMemstatsHeapInuse {
	m := metricProcessRuntimeMemstatsHeapInuse{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricProcessRuntimeMemstatsHeapObjects struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills process.runtime.memstats.heap_objects metric with initial data.
func (m *metricProcessRuntimeMemstatsHeapObjects) init() {
	m.data.SetName("process.runtime.memstats.heap_objects")
	m.data.SetDescription("Number of allocated heap objects.")
	m.data.SetUnit("{objects}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricProcessRuntimeMemstatsHeapObjects) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricProcessRuntimeMemstatsHeapObjects) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricProcessRuntimeMemstatsHeapObjects) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricProcessRuntimeMemstatsHeapObjects(settings MetricSettings) metricProcessRuntimeMemstatsHeapObjects {
	m := metricProcessRuntimeMemstatsHeapObjects{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricProcessRuntimeMemstatsHeapReleased struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills process.runtime.memstats.heap_released metric with initial data.
func (m *metricProcessRuntimeMemstatsHeapReleased) init() {
	m.data.SetName("process.runtime.memstats.heap_released")
	m.data.SetDescription("Bytes of physical memory returned to the OS.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricProcessRuntimeMemstatsHeapReleased) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricProcessRuntimeMemstatsHeapReleased) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricProcessRuntimeMemstatsHeapReleased) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricProcessRuntimeMemstatsHeapReleased(settings MetricSettings) metricProcessRuntimeMemstatsHeapReleased {
	m := metricProcessRuntimeMemstatsHeapReleased{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricProcessRuntimeMemstatsHeapSys struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills process.runtime.memstats.heap_sys metric with initial data.
func (m *metricProcessRuntimeMemstatsHeapSys) init() {
	m.data.SetName("process.runtime.memstats.heap_sys")
	m.data.SetDescription("Bytes of heap memory obtained by the OS.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricProcessRuntimeMemstatsHeapSys) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricProcessRuntimeMemstatsHeapSys) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricProcessRuntimeMemstatsHeapSys) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricProcessRuntimeMemstatsHeapSys(settings MetricSettings) metricProcessRuntimeMemstatsHeapSys {
	m := metricProcessRuntimeMemstatsHeapSys{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricProcessRuntimeMemstatsLastPause struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills process.runtime.memstats.last_pause metric with initial data.
func (m *metricProcessRuntimeMemstatsLastPause) init() {
	m.data.SetName("process.runtime.memstats.last_pause")
	m.data.SetDescription("The most recent stop-the-world pause time.")
	m.data.SetUnit("ns")
	m.data.SetEmptyGauge()
}

func (m *metricProcessRuntimeMemstatsLastPause) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricProcessRuntimeMemstatsLastPause) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricProcessRuntimeMemstatsLastPause) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricProcessRuntimeMemstatsLastPause(settings MetricSettings) metricProcessRuntimeMemstatsLastPause {
	m := metricProcessRuntimeMemstatsLastPause{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricProcessRuntimeMemstatsLookups struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills process.runtime.memstats.lookups metric with initial data.
func (m *metricProcessRuntimeMemstatsLookups) init() {
	m.data.SetName("process.runtime.memstats.lookups")
	m.data.SetDescription("Number of pointer lookups performed by the runtime.")
	m.data.SetUnit("{lookups}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricProcessRuntimeMemstatsLookups) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricProcessRuntimeMemstatsLookups) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricProcessRuntimeMemstatsLookups) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricProcessRuntimeMemstatsLookups(settings MetricSettings) metricProcessRuntimeMemstatsLookups {
	m := metricProcessRuntimeMemstatsLookups{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricProcessRuntimeMemstatsMallocs struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills process.runtime.memstats.mallocs metric with initial data.
func (m *metricProcessRuntimeMemstatsMallocs) init() {
	m.data.SetName("process.runtime.memstats.mallocs")
	m.data.SetDescription("Cumulative count of heap objects allocated.")
	m.data.SetUnit("{objects}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricProcessRuntimeMemstatsMallocs) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricProcessRuntimeMemstatsMallocs) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricProcessRuntimeMemstatsMallocs) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricProcessRuntimeMemstatsMallocs(settings MetricSettings) metricProcessRuntimeMemstatsMallocs {
	m := metricProcessRuntimeMemstatsMallocs{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricProcessRuntimeMemstatsMcacheInuse struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills process.runtime.memstats.mcache_inuse metric with initial data.
func (m *metricProcessRuntimeMemstatsMcacheInuse) init() {
	m.data.SetName("process.runtime.memstats.mcache_inuse")
	m.data.SetDescription("Bytes of allocated mcache structures.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricProcessRuntimeMemstatsMcacheInuse) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricProcessRuntimeMemstatsMcacheInuse) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricProcessRuntimeMemstatsMcacheInuse) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricProcessRuntimeMemstatsMcacheInuse(settings MetricSettings) metricProcessRuntimeMemstatsMcacheInuse {
	m := metricProcessRuntimeMemstatsMcacheInuse{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricProcessRuntimeMemstatsMcacheSys struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills process.runtime.memstats.mcache_sys metric with initial data.
func (m *metricProcessRuntimeMemstatsMcacheSys) init() {
	m.data.SetName("process.runtime.memstats.mcache_sys")
	m.data.SetDescription("Bytes of memory obtained from the OS for mcache structures.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricProcessRuntimeMemstatsMcacheSys) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricProcessRuntimeMemstatsMcacheSys) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricProcessRuntimeMemstatsMcacheSys) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricProcessRuntimeMemstatsMcacheSys(settings MetricSettings) metricProcessRuntimeMemstatsMcacheSys {
	m := metricProcessRuntimeMemstatsMcacheSys{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricProcessRuntimeMemstatsMspanInuse struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills process.runtime.memstats.mspan_inuse metric with initial data.
func (m *metricProcessRuntimeMemstatsMspanInuse) init() {
	m.data.SetName("process.runtime.memstats.mspan_inuse")
	m.data.SetDescription("Bytes of allocated mspan structures.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricProcessRuntimeMemstatsMspanInuse) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricProcessRuntimeMemstatsMspanInuse) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricProcessRuntimeMemstatsMspanInuse) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricProcessRuntimeMemstatsMspanInuse(settings MetricSettings) metricProcessRuntimeMemstatsMspanInuse {
	m := metricProcessRuntimeMemstatsMspanInuse{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricProcessRuntimeMemstatsMspanSys struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills process.runtime.memstats.mspan_sys metric with initial data.
func (m *metricProcessRuntimeMemstatsMspanSys) init() {
	m.data.SetName("process.runtime.memstats.mspan_sys")
	m.data.SetDescription("Bytes of memory obtained from the OS for mspan structures.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricProcessRuntimeMemstatsMspanSys) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricProcessRuntimeMemstatsMspanSys) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricProcessRuntimeMemstatsMspanSys) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricProcessRuntimeMemstatsMspanSys(settings MetricSettings) metricProcessRuntimeMemstatsMspanSys {
	m := metricProcessRuntimeMemstatsMspanSys{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricProcessRuntimeMemstatsNextGc struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills process.runtime.memstats.next_gc metric with initial data.
func (m *metricProcessRuntimeMemstatsNextGc) init() {
	m.data.SetName("process.runtime.memstats.next_gc")
	m.data.SetDescription("The target heap size of the next GC cycle.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricProcessRuntimeMemstatsNextGc) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricProcessRuntimeMemstatsNextGc) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricProcessRuntimeMemstatsNextGc) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricProcessRuntimeMemstatsNextGc(settings MetricSettings) metricProcessRuntimeMemstatsNextGc {
	m := metricProcessRuntimeMemstatsNextGc{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricProcessRuntimeMemstatsNumForcedGc struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills process.runtime.memstats.num_forced_gc metric with initial data.
func (m *metricProcessRuntimeMemstatsNumForcedGc) init() {
	m.data.SetName("process.runtime.memstats.num_forced_gc")
	m.data.SetDescription("Number of GC cycles that were forced by the application calling the GC function.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricProcessRuntimeMemstatsNumForcedGc) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricProcessRuntimeMemstatsNumForcedGc) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricProcessRuntimeMemstatsNumForcedGc) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricProcessRuntimeMemstatsNumForcedGc(settings MetricSettings) metricProcessRuntimeMemstatsNumForcedGc {
	m := metricProcessRuntimeMemstatsNumForcedGc{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricProcessRuntimeMemstatsNumGc struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills process.runtime.memstats.num_gc metric with initial data.
func (m *metricProcessRuntimeMemstatsNumGc) init() {
	m.data.SetName("process.runtime.memstats.num_gc")
	m.data.SetDescription("Number of completed GC cycles.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricProcessRuntimeMemstatsNumGc) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricProcessRuntimeMemstatsNumGc) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricProcessRuntimeMemstatsNumGc) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricProcessRuntimeMemstatsNumGc(settings MetricSettings) metricProcessRuntimeMemstatsNumGc {
	m := metricProcessRuntimeMemstatsNumGc{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricProcessRuntimeMemstatsOtherSys struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills process.runtime.memstats.other_sys metric with initial data.
func (m *metricProcessRuntimeMemstatsOtherSys) init() {
	m.data.SetName("process.runtime.memstats.other_sys")
	m.data.SetDescription("Bytes of memory in miscellaneous off-heap runtime allocations.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricProcessRuntimeMemstatsOtherSys) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricProcessRuntimeMemstatsOtherSys) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricProcessRuntimeMemstatsOtherSys) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricProcessRuntimeMemstatsOtherSys(settings MetricSettings) metricProcessRuntimeMemstatsOtherSys {
	m := metricProcessRuntimeMemstatsOtherSys{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricProcessRuntimeMemstatsPauseTotal struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills process.runtime.memstats.pause_total metric with initial data.
func (m *metricProcessRuntimeMemstatsPauseTotal) init() {
	m.data.SetName("process.runtime.memstats.pause_total")
	m.data.SetDescription("The cumulative nanoseconds in GC stop-the-world pauses since the program started.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricProcessRuntimeMemstatsPauseTotal) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricProcessRuntimeMemstatsPauseTotal) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricProcessRuntimeMemstatsPauseTotal) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricProcessRuntimeMemstatsPauseTotal(settings MetricSettings) metricProcessRuntimeMemstatsPauseTotal {
	m := metricProcessRuntimeMemstatsPauseTotal{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricProcessRuntimeMemstatsStackInuse struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills process.runtime.memstats.stack_inuse metric with initial data.
func (m *metricProcessRuntimeMemstatsStackInuse) init() {
	m.data.SetName("process.runtime.memstats.stack_inuse")
	m.data.SetDescription("Bytes in stack spans.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricProcessRuntimeMemstatsStackInuse) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricProcessRuntimeMemstatsStackInuse) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricProcessRuntimeMemstatsStackInuse) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricProcessRuntimeMemstatsStackInuse(settings MetricSettings) metricProcessRuntimeMemstatsStackInuse {
	m := metricProcessRuntimeMemstatsStackInuse{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricProcessRuntimeMemstatsStackSys struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills process.runtime.memstats.stack_sys metric with initial data.
func (m *metricProcessRuntimeMemstatsStackSys) init() {
	m.data.SetName("process.runtime.memstats.stack_sys")
	m.data.SetDescription("Bytes of stack memory obtained from the OS.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricProcessRuntimeMemstatsStackSys) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricProcessRuntimeMemstatsStackSys) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricProcessRuntimeMemstatsStackSys) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricProcessRuntimeMemstatsStackSys(settings MetricSettings) metricProcessRuntimeMemstatsStackSys {
	m := metricProcessRuntimeMemstatsStackSys{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricProcessRuntimeMemstatsSys struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills process.runtime.memstats.sys metric with initial data.
func (m *metricProcessRuntimeMemstatsSys) init() {
	m.data.SetName("process.runtime.memstats.sys")
	m.data.SetDescription("Total bytes of memory obtained from the OS.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricProcessRuntimeMemstatsSys) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricProcessRuntimeMemstatsSys) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricProcessRuntimeMemstatsSys) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricProcessRuntimeMemstatsSys(settings MetricSettings) metricProcessRuntimeMemstatsSys {
	m := metricProcessRuntimeMemstatsSys{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricProcessRuntimeMemstatsTotalAlloc struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills process.runtime.memstats.total_alloc metric with initial data.
func (m *metricProcessRuntimeMemstatsTotalAlloc) init() {
	m.data.SetName("process.runtime.memstats.total_alloc")
	m.data.SetDescription("Cumulative bytes allocated for heap objects.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricProcessRuntimeMemstatsTotalAlloc) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricProcessRuntimeMemstatsTotalAlloc) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricProcessRuntimeMemstatsTotalAlloc) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricProcessRuntimeMemstatsTotalAlloc(settings MetricSettings) metricProcessRuntimeMemstatsTotalAlloc {
	m := metricProcessRuntimeMemstatsTotalAlloc{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

// MetricsBuilderConfig is a structural subset of an otherwise 1-1 copy of metadata.yaml
type MetricsBuilderConfig struct {
	Metrics            MetricsSettings            `mapstructure:"metrics"`
	ResourceAttributes ResourceAttributesSettings `mapstructure:"resource_attributes"`
}

// MetricsBuilder provides an interface for scrapers to report metrics while taking care of all the transformations
// required to produce metric representation defined in metadata and user settings.
type MetricsBuilder struct {
	startTime                                 pcommon.Timestamp   // start time that will be applied to all recorded data points.
	metricsCapacity                           int                 // maximum observed number of metrics per resource.
	resourceCapacity                          int                 // maximum observed number of resource attributes.
	metricsBuffer                             pmetric.Metrics     // accumulates metrics data before emitting.
	buildInfo                                 component.BuildInfo // contains version information
	resourceAttributesSettings                ResourceAttributesSettings
	metricProcessRuntimeMemstatsBuckHashSys   metricProcessRuntimeMemstatsBuckHashSys
	metricProcessRuntimeMemstatsFrees         metricProcessRuntimeMemstatsFrees
	metricProcessRuntimeMemstatsGcCPUFraction metricProcessRuntimeMemstatsGcCPUFraction
	metricProcessRuntimeMemstatsGcSys         metricProcessRuntimeMemstatsGcSys
	metricProcessRuntimeMemstatsHeapAlloc     metricProcessRuntimeMemstatsHeapAlloc
	metricProcessRuntimeMemstatsHeapIdle      metricProcessRuntimeMemstatsHeapIdle
	metricProcessRuntimeMemstatsHeapInuse     metricProcessRuntimeMemstatsHeapInuse
	metricProcessRuntimeMemstatsHeapObjects   metricProcessRuntimeMemstatsHeapObjects
	metricProcessRuntimeMemstatsHeapReleased  metricProcessRuntimeMemstatsHeapReleased
	metricProcessRuntimeMemstatsHeapSys       metricProcessRuntimeMemstatsHeapSys
	metricProcessRuntimeMemstatsLastPause     metricProcessRuntimeMemstatsLastPause
	metricProcessRuntimeMemstatsLookups       metricProcessRuntimeMemstatsLookups
	metricProcessRuntimeMemstatsMallocs       metricProcessRuntimeMemstatsMallocs
	metricProcessRuntimeMemstatsMcacheInuse   metricProcessRuntimeMemstatsMcacheInuse
	metricProcessRuntimeMemstatsMcacheSys     metricProcessRuntimeMemstatsMcacheSys
	metricProcessRuntimeMemstatsMspanInuse    metricProcessRuntimeMemstatsMspanInuse
	metricProcessRuntimeMemstatsMspanSys      metricProcessRuntimeMemstatsMspanSys
	metricProcessRuntimeMemstatsNextGc        metricProcessRuntimeMemstatsNextGc
	metricProcessRuntimeMemstatsNumForcedGc   metricProcessRuntimeMemstatsNumForcedGc
	metricProcessRuntimeMemstatsNumGc         metricProcessRuntimeMemstatsNumGc
	metricProcessRuntimeMemstatsOtherSys      metricProcessRuntimeMemstatsOtherSys
	metricProcessRuntimeMemstatsPauseTotal    metricProcessRuntimeMemstatsPauseTotal
	metricProcessRuntimeMemstatsStackInuse    metricProcessRuntimeMemstatsStackInuse
	metricProcessRuntimeMemstatsStackSys      metricProcessRuntimeMemstatsStackSys
	metricProcessRuntimeMemstatsSys           metricProcessRuntimeMemstatsSys
	metricProcessRuntimeMemstatsTotalAlloc    metricProcessRuntimeMemstatsTotalAlloc
}

// metricBuilderOption applies changes to default metrics builder.
type metricBuilderOption func(*MetricsBuilder)

// WithStartTime sets startTime on the metrics builder.
func WithStartTime(startTime pcommon.Timestamp) metricBuilderOption {
	return func(mb *MetricsBuilder) {
		mb.startTime = startTime
	}
}

func DefaultMetricsBuilderConfig() MetricsBuilderConfig {
	return MetricsBuilderConfig{
		Metrics:            DefaultMetricsSettings(),
		ResourceAttributes: DefaultResourceAttributesSettings(),
	}
}

func NewMetricsBuilderConfig(ms MetricsSettings, ras ResourceAttributesSettings) MetricsBuilderConfig {
	return MetricsBuilderConfig{
		Metrics:            ms,
		ResourceAttributes: ras,
	}
}

func NewMetricsBuilder(mbc MetricsBuilderConfig, settings receiver.CreateSettings, options ...metricBuilderOption) *MetricsBuilder {
	mb := &MetricsBuilder{
		startTime:                                 pcommon.NewTimestampFromTime(time.Now()),
		metricsBuffer:                             pmetric.NewMetrics(),
		buildInfo:                                 settings.BuildInfo,
		resourceAttributesSettings:                mbc.ResourceAttributes,
		metricProcessRuntimeMemstatsBuckHashSys:   newMetricProcessRuntimeMemstatsBuckHashSys(mbc.Metrics.ProcessRuntimeMemstatsBuckHashSys),
		metricProcessRuntimeMemstatsFrees:         newMetricProcessRuntimeMemstatsFrees(mbc.Metrics.ProcessRuntimeMemstatsFrees),
		metricProcessRuntimeMemstatsGcCPUFraction: newMetricProcessRuntimeMemstatsGcCPUFraction(mbc.Metrics.ProcessRuntimeMemstatsGcCPUFraction),
		metricProcessRuntimeMemstatsGcSys:         newMetricProcessRuntimeMemstatsGcSys(mbc.Metrics.ProcessRuntimeMemstatsGcSys),
		metricProcessRuntimeMemstatsHeapAlloc:     newMetricProcessRuntimeMemstatsHeapAlloc(mbc.Metrics.ProcessRuntimeMemstatsHeapAlloc),
		metricProcessRuntimeMemstatsHeapIdle:      newMetricProcessRuntimeMemstatsHeapIdle(mbc.Metrics.ProcessRuntimeMemstatsHeapIdle),
		metricProcessRuntimeMemstatsHeapInuse:     newMetricProcessRuntimeMemstatsHeapInuse(mbc.Metrics.ProcessRuntimeMemstatsHeapInuse),
		metricProcessRuntimeMemstatsHeapObjects:   newMetricProcessRuntimeMemstatsHeapObjects(mbc.Metrics.ProcessRuntimeMemstatsHeapObjects),
		metricProcessRuntimeMemstatsHeapReleased:  newMetricProcessRuntimeMemstatsHeapReleased(mbc.Metrics.ProcessRuntimeMemstatsHeapReleased),
		metricProcessRuntimeMemstatsHeapSys:       newMetricProcessRuntimeMemstatsHeapSys(mbc.Metrics.ProcessRuntimeMemstatsHeapSys),
		metricProcessRuntimeMemstatsLastPause:     newMetricProcessRuntimeMemstatsLastPause(mbc.Metrics.ProcessRuntimeMemstatsLastPause),
		metricProcessRuntimeMemstatsLookups:       newMetricProcessRuntimeMemstatsLookups(mbc.Metrics.ProcessRuntimeMemstatsLookups),
		metricProcessRuntimeMemstatsMallocs:       newMetricProcessRuntimeMemstatsMallocs(mbc.Metrics.ProcessRuntimeMemstatsMallocs),
		metricProcessRuntimeMemstatsMcacheInuse:   newMetricProcessRuntimeMemstatsMcacheInuse(mbc.Metrics.ProcessRuntimeMemstatsMcacheInuse),
		metricProcessRuntimeMemstatsMcacheSys:     newMetricProcessRuntimeMemstatsMcacheSys(mbc.Metrics.ProcessRuntimeMemstatsMcacheSys),
		metricProcessRuntimeMemstatsMspanInuse:    newMetricProcessRuntimeMemstatsMspanInuse(mbc.Metrics.ProcessRuntimeMemstatsMspanInuse),
		metricProcessRuntimeMemstatsMspanSys:      newMetricProcessRuntimeMemstatsMspanSys(mbc.Metrics.ProcessRuntimeMemstatsMspanSys),
		metricProcessRuntimeMemstatsNextGc:        newMetricProcessRuntimeMemstatsNextGc(mbc.Metrics.ProcessRuntimeMemstatsNextGc),
		metricProcessRuntimeMemstatsNumForcedGc:   newMetricProcessRuntimeMemstatsNumForcedGc(mbc.Metrics.ProcessRuntimeMemstatsNumForcedGc),
		metricProcessRuntimeMemstatsNumGc:         newMetricProcessRuntimeMemstatsNumGc(mbc.Metrics.ProcessRuntimeMemstatsNumGc),
		metricProcessRuntimeMemstatsOtherSys:      newMetricProcessRuntimeMemstatsOtherSys(mbc.Metrics.ProcessRuntimeMemstatsOtherSys),
		metricProcessRuntimeMemstatsPauseTotal:    newMetricProcessRuntimeMemstatsPauseTotal(mbc.Metrics.ProcessRuntimeMemstatsPauseTotal),
		metricProcessRuntimeMemstatsStackInuse:    newMetricProcessRuntimeMemstatsStackInuse(mbc.Metrics.ProcessRuntimeMemstatsStackInuse),
		metricProcessRuntimeMemstatsStackSys:      newMetricProcessRuntimeMemstatsStackSys(mbc.Metrics.ProcessRuntimeMemstatsStackSys),
		metricProcessRuntimeMemstatsSys:           newMetricProcessRuntimeMemstatsSys(mbc.Metrics.ProcessRuntimeMemstatsSys),
		metricProcessRuntimeMemstatsTotalAlloc:    newMetricProcessRuntimeMemstatsTotalAlloc(mbc.Metrics.ProcessRuntimeMemstatsTotalAlloc),
	}
	for _, op := range options {
		op(mb)
	}
	return mb
}

// updateCapacity updates max length of metrics and resource attributes that will be used for the slice capacity.
func (mb *MetricsBuilder) updateCapacity(rm pmetric.ResourceMetrics) {
	if mb.metricsCapacity < rm.ScopeMetrics().At(0).Metrics().Len() {
		mb.metricsCapacity = rm.ScopeMetrics().At(0).Metrics().Len()
	}
	if mb.resourceCapacity < rm.Resource().Attributes().Len() {
		mb.resourceCapacity = rm.Resource().Attributes().Len()
	}
}

// ResourceMetricsOption applies changes to provided resource metrics.
type ResourceMetricsOption func(ResourceAttributesSettings, pmetric.ResourceMetrics)

// WithStartTimeOverride overrides start time for all the resource metrics data points.
// This option should be only used if different start time has to be set on metrics coming from different resources.
func WithStartTimeOverride(start pcommon.Timestamp) ResourceMetricsOption {
	return func(ras ResourceAttributesSettings, rm pmetric.ResourceMetrics) {
		var dps pmetric.NumberDataPointSlice
		metrics := rm.ScopeMetrics().At(0).Metrics()
		for i := 0; i < metrics.Len(); i++ {
			switch metrics.At(i).Type() {
			case pmetric.MetricTypeGauge:
				dps = metrics.At(i).Gauge().DataPoints()
			case pmetric.MetricTypeSum:
				dps = metrics.At(i).Sum().DataPoints()
			}
			for j := 0; j < dps.Len(); j++ {
				dps.At(j).SetStartTimestamp(start)
			}
		}
	}
}

// EmitForResource saves all the generated metrics under a new resource and updates the internal state to be ready for
// recording another set of data points as part of another resource. This function can be helpful when one scraper
// needs to emit metrics from several resources. Otherwise calling this function is not required,
// just `Emit` function can be called instead.
// Resource attributes should be provided as ResourceMetricsOption arguments.
func (mb *MetricsBuilder) EmitForResource(rmo ...ResourceMetricsOption) {
	rm := pmetric.NewResourceMetrics()
	rm.Resource().Attributes().EnsureCapacity(mb.resourceCapacity)
	ils := rm.ScopeMetrics().AppendEmpty()
	ils.Scope().SetName("otelcol/expvarreceiver")
	ils.Scope().SetVersion(mb.buildInfo.Version)
	ils.Metrics().EnsureCapacity(mb.metricsCapacity)
	mb.metricProcessRuntimeMemstatsBuckHashSys.emit(ils.Metrics())
	mb.metricProcessRuntimeMemstatsFrees.emit(ils.Metrics())
	mb.metricProcessRuntimeMemstatsGcCPUFraction.emit(ils.Metrics())
	mb.metricProcessRuntimeMemstatsGcSys.emit(ils.Metrics())
	mb.metricProcessRuntimeMemstatsHeapAlloc.emit(ils.Metrics())
	mb.metricProcessRuntimeMemstatsHeapIdle.emit(ils.Metrics())
	mb.metricProcessRuntimeMemstatsHeapInuse.emit(ils.Metrics())
	mb.metricProcessRuntimeMemstatsHeapObjects.emit(ils.Metrics())
	mb.metricProcessRuntimeMemstatsHeapReleased.emit(ils.Metrics())
	mb.metricProcessRuntimeMemstatsHeapSys.emit(ils.Metrics())
	mb.metricProcessRuntimeMemstatsLastPause.emit(ils.Metrics())
	mb.metricProcessRuntimeMemstatsLookups.emit(ils.Metrics())
	mb.metricProcessRuntimeMemstatsMallocs.emit(ils.Metrics())
	mb.metricProcessRuntimeMemstatsMcacheInuse.emit(ils.Metrics())
	mb.metricProcessRuntimeMemstatsMcacheSys.emit(ils.Metrics())
	mb.metricProcessRuntimeMemstatsMspanInuse.emit(ils.Metrics())
	mb.metricProcessRuntimeMemstatsMspanSys.emit(ils.Metrics())
	mb.metricProcessRuntimeMemstatsNextGc.emit(ils.Metrics())
	mb.metricProcessRuntimeMemstatsNumForcedGc.emit(ils.Metrics())
	mb.metricProcessRuntimeMemstatsNumGc.emit(ils.Metrics())
	mb.metricProcessRuntimeMemstatsOtherSys.emit(ils.Metrics())
	mb.metricProcessRuntimeMemstatsPauseTotal.emit(ils.Metrics())
	mb.metricProcessRuntimeMemstatsStackInuse.emit(ils.Metrics())
	mb.metricProcessRuntimeMemstatsStackSys.emit(ils.Metrics())
	mb.metricProcessRuntimeMemstatsSys.emit(ils.Metrics())
	mb.metricProcessRuntimeMemstatsTotalAlloc.emit(ils.Metrics())

	for _, op := range rmo {
		op(mb.resourceAttributesSettings, rm)
	}
	if ils.Metrics().Len() > 0 {
		mb.updateCapacity(rm)
		rm.MoveTo(mb.metricsBuffer.ResourceMetrics().AppendEmpty())
	}
}

// Emit returns all the metrics accumulated by the metrics builder and updates the internal state to be ready for
// recording another set of metrics. This function will be responsible for applying all the transformations required to
// produce metric representation defined in metadata and user settings, e.g. delta or cumulative.
func (mb *MetricsBuilder) Emit(rmo ...ResourceMetricsOption) pmetric.Metrics {
	mb.EmitForResource(rmo...)
	metrics := mb.metricsBuffer
	mb.metricsBuffer = pmetric.NewMetrics()
	return metrics
}

// RecordProcessRuntimeMemstatsBuckHashSysDataPoint adds a data point to process.runtime.memstats.buck_hash_sys metric.
func (mb *MetricsBuilder) RecordProcessRuntimeMemstatsBuckHashSysDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricProcessRuntimeMemstatsBuckHashSys.recordDataPoint(mb.startTime, ts, val)
}

// RecordProcessRuntimeMemstatsFreesDataPoint adds a data point to process.runtime.memstats.frees metric.
func (mb *MetricsBuilder) RecordProcessRuntimeMemstatsFreesDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricProcessRuntimeMemstatsFrees.recordDataPoint(mb.startTime, ts, val)
}

// RecordProcessRuntimeMemstatsGcCPUFractionDataPoint adds a data point to process.runtime.memstats.gc_cpu_fraction metric.
func (mb *MetricsBuilder) RecordProcessRuntimeMemstatsGcCPUFractionDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricProcessRuntimeMemstatsGcCPUFraction.recordDataPoint(mb.startTime, ts, val)
}

// RecordProcessRuntimeMemstatsGcSysDataPoint adds a data point to process.runtime.memstats.gc_sys metric.
func (mb *MetricsBuilder) RecordProcessRuntimeMemstatsGcSysDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricProcessRuntimeMemstatsGcSys.recordDataPoint(mb.startTime, ts, val)
}

// RecordProcessRuntimeMemstatsHeapAllocDataPoint adds a data point to process.runtime.memstats.heap_alloc metric.
func (mb *MetricsBuilder) RecordProcessRuntimeMemstatsHeapAllocDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricProcessRuntimeMemstatsHeapAlloc.recordDataPoint(mb.startTime, ts, val)
}

// RecordProcessRuntimeMemstatsHeapIdleDataPoint adds a data point to process.runtime.memstats.heap_idle metric.
func (mb *MetricsBuilder) RecordProcessRuntimeMemstatsHeapIdleDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricProcessRuntimeMemstatsHeapIdle.recordDataPoint(mb.startTime, ts, val)
}

// RecordProcessRuntimeMemstatsHeapInuseDataPoint adds a data point to process.runtime.memstats.heap_inuse metric.
func (mb *MetricsBuilder) RecordProcessRuntimeMemstatsHeapInuseDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricProcessRuntimeMemstatsHeapInuse.recordDataPoint(mb.startTime, ts, val)
}

// RecordProcessRuntimeMemstatsHeapObjectsDataPoint adds a data point to process.runtime.memstats.heap_objects metric.
func (mb *MetricsBuilder) RecordProcessRuntimeMemstatsHeapObjectsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricProcessRuntimeMemstatsHeapObjects.recordDataPoint(mb.startTime, ts, val)
}

// RecordProcessRuntimeMemstatsHeapReleasedDataPoint adds a data point to process.runtime.memstats.heap_released metric.
func (mb *MetricsBuilder) RecordProcessRuntimeMemstatsHeapReleasedDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricProcessRuntimeMemstatsHeapReleased.recordDataPoint(mb.startTime, ts, val)
}

// RecordProcessRuntimeMemstatsHeapSysDataPoint adds a data point to process.runtime.memstats.heap_sys metric.
func (mb *MetricsBuilder) RecordProcessRuntimeMemstatsHeapSysDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricProcessRuntimeMemstatsHeapSys.recordDataPoint(mb.startTime, ts, val)
}

// RecordProcessRuntimeMemstatsLastPauseDataPoint adds a data point to process.runtime.memstats.last_pause metric.
func (mb *MetricsBuilder) RecordProcessRuntimeMemstatsLastPauseDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricProcessRuntimeMemstatsLastPause.recordDataPoint(mb.startTime, ts, val)
}

// RecordProcessRuntimeMemstatsLookupsDataPoint adds a data point to process.runtime.memstats.lookups metric.
func (mb *MetricsBuilder) RecordProcessRuntimeMemstatsLookupsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricProcessRuntimeMemstatsLookups.recordDataPoint(mb.startTime, ts, val)
}

// RecordProcessRuntimeMemstatsMallocsDataPoint adds a data point to process.runtime.memstats.mallocs metric.
func (mb *MetricsBuilder) RecordProcessRuntimeMemstatsMallocsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricProcessRuntimeMemstatsMallocs.recordDataPoint(mb.startTime, ts, val)
}

// RecordProcessRuntimeMemstatsMcacheInuseDataPoint adds a data point to process.runtime.memstats.mcache_inuse metric.
func (mb *MetricsBuilder) RecordProcessRuntimeMemstatsMcacheInuseDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricProcessRuntimeMemstatsMcacheInuse.recordDataPoint(mb.startTime, ts, val)
}

// RecordProcessRuntimeMemstatsMcacheSysDataPoint adds a data point to process.runtime.memstats.mcache_sys metric.
func (mb *MetricsBuilder) RecordProcessRuntimeMemstatsMcacheSysDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricProcessRuntimeMemstatsMcacheSys.recordDataPoint(mb.startTime, ts, val)
}

// RecordProcessRuntimeMemstatsMspanInuseDataPoint adds a data point to process.runtime.memstats.mspan_inuse metric.
func (mb *MetricsBuilder) RecordProcessRuntimeMemstatsMspanInuseDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricProcessRuntimeMemstatsMspanInuse.recordDataPoint(mb.startTime, ts, val)
}

// RecordProcessRuntimeMemstatsMspanSysDataPoint adds a data point to process.runtime.memstats.mspan_sys metric.
func (mb *MetricsBuilder) RecordProcessRuntimeMemstatsMspanSysDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricProcessRuntimeMemstatsMspanSys.recordDataPoint(mb.startTime, ts, val)
}

// RecordProcessRuntimeMemstatsNextGcDataPoint adds a data point to process.runtime.memstats.next_gc metric.
func (mb *MetricsBuilder) RecordProcessRuntimeMemstatsNextGcDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricProcessRuntimeMemstatsNextGc.recordDataPoint(mb.startTime, ts, val)
}

// RecordProcessRuntimeMemstatsNumForcedGcDataPoint adds a data point to process.runtime.memstats.num_forced_gc metric.
func (mb *MetricsBuilder) RecordProcessRuntimeMemstatsNumForcedGcDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricProcessRuntimeMemstatsNumForcedGc.recordDataPoint(mb.startTime, ts, val)
}

// RecordProcessRuntimeMemstatsNumGcDataPoint adds a data point to process.runtime.memstats.num_gc metric.
func (mb *MetricsBuilder) RecordProcessRuntimeMemstatsNumGcDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricProcessRuntimeMemstatsNumGc.recordDataPoint(mb.startTime, ts, val)
}

// RecordProcessRuntimeMemstatsOtherSysDataPoint adds a data point to process.runtime.memstats.other_sys metric.
func (mb *MetricsBuilder) RecordProcessRuntimeMemstatsOtherSysDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricProcessRuntimeMemstatsOtherSys.recordDataPoint(mb.startTime, ts, val)
}

// RecordProcessRuntimeMemstatsPauseTotalDataPoint adds a data point to process.runtime.memstats.pause_total metric.
func (mb *MetricsBuilder) RecordProcessRuntimeMemstatsPauseTotalDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricProcessRuntimeMemstatsPauseTotal.recordDataPoint(mb.startTime, ts, val)
}

// RecordProcessRuntimeMemstatsStackInuseDataPoint adds a data point to process.runtime.memstats.stack_inuse metric.
func (mb *MetricsBuilder) RecordProcessRuntimeMemstatsStackInuseDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricProcessRuntimeMemstatsStackInuse.recordDataPoint(mb.startTime, ts, val)
}

// RecordProcessRuntimeMemstatsStackSysDataPoint adds a data point to process.runtime.memstats.stack_sys metric.
func (mb *MetricsBuilder) RecordProcessRuntimeMemstatsStackSysDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricProcessRuntimeMemstatsStackSys.recordDataPoint(mb.startTime, ts, val)
}

// RecordProcessRuntimeMemstatsSysDataPoint adds a data point to process.runtime.memstats.sys metric.
func (mb *MetricsBuilder) RecordProcessRuntimeMemstatsSysDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricProcessRuntimeMemstatsSys.recordDataPoint(mb.startTime, ts, val)
}

// RecordProcessRuntimeMemstatsTotalAllocDataPoint adds a data point to process.runtime.memstats.total_alloc metric.
func (mb *MetricsBuilder) RecordProcessRuntimeMemstatsTotalAllocDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricProcessRuntimeMemstatsTotalAlloc.recordDataPoint(mb.startTime, ts, val)
}

// Reset resets metrics builder to its initial state. It should be used when external metrics source is restarted,
// and metrics builder should update its startTime and reset it's internal state accordingly.
func (mb *MetricsBuilder) Reset(options ...metricBuilderOption) {
	mb.startTime = pcommon.NewTimestampFromTime(time.Now())
	for _, op := range options {
		op(mb)
	}
}
