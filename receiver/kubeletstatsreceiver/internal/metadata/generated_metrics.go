// Code generated by mdatagen. DO NOT EDIT.

package metadata

import (
	"time"

	"go.opentelemetry.io/collector/component"
	"go.opentelemetry.io/collector/confmap"
	"go.opentelemetry.io/collector/pdata/pcommon"
	"go.opentelemetry.io/collector/pdata/pmetric"
	"go.opentelemetry.io/collector/receiver"
)

// MetricSettings provides common settings for a particular metric.
type MetricSettings struct {
	Enabled bool `mapstructure:"enabled"`

	enabledSetByUser bool
}

func (ms *MetricSettings) Unmarshal(parser *confmap.Conf) error {
	if parser == nil {
		return nil
	}
	err := parser.Unmarshal(ms, confmap.WithErrorUnused())
	if err != nil {
		return err
	}
	ms.enabledSetByUser = parser.IsSet("enabled")
	return nil
}

// MetricsSettings provides settings for kubeletstatsreceiver metrics.
type MetricsSettings struct {
	ContainerCPUTime               MetricSettings `mapstructure:"container.cpu.time"`
	ContainerCPUUtilization        MetricSettings `mapstructure:"container.cpu.utilization"`
	ContainerFilesystemAvailable   MetricSettings `mapstructure:"container.filesystem.available"`
	ContainerFilesystemCapacity    MetricSettings `mapstructure:"container.filesystem.capacity"`
	ContainerFilesystemUsage       MetricSettings `mapstructure:"container.filesystem.usage"`
	ContainerMemoryAvailable       MetricSettings `mapstructure:"container.memory.available"`
	ContainerMemoryMajorPageFaults MetricSettings `mapstructure:"container.memory.major_page_faults"`
	ContainerMemoryPageFaults      MetricSettings `mapstructure:"container.memory.page_faults"`
	ContainerMemoryRss             MetricSettings `mapstructure:"container.memory.rss"`
	ContainerMemoryUsage           MetricSettings `mapstructure:"container.memory.usage"`
	ContainerMemoryWorkingSet      MetricSettings `mapstructure:"container.memory.working_set"`
	K8sNodeCPUTime                 MetricSettings `mapstructure:"k8s.node.cpu.time"`
	K8sNodeCPUUtilization          MetricSettings `mapstructure:"k8s.node.cpu.utilization"`
	K8sNodeFilesystemAvailable     MetricSettings `mapstructure:"k8s.node.filesystem.available"`
	K8sNodeFilesystemCapacity      MetricSettings `mapstructure:"k8s.node.filesystem.capacity"`
	K8sNodeFilesystemUsage         MetricSettings `mapstructure:"k8s.node.filesystem.usage"`
	K8sNodeMemoryAvailable         MetricSettings `mapstructure:"k8s.node.memory.available"`
	K8sNodeMemoryMajorPageFaults   MetricSettings `mapstructure:"k8s.node.memory.major_page_faults"`
	K8sNodeMemoryPageFaults        MetricSettings `mapstructure:"k8s.node.memory.page_faults"`
	K8sNodeMemoryRss               MetricSettings `mapstructure:"k8s.node.memory.rss"`
	K8sNodeMemoryUsage             MetricSettings `mapstructure:"k8s.node.memory.usage"`
	K8sNodeMemoryWorkingSet        MetricSettings `mapstructure:"k8s.node.memory.working_set"`
	K8sNodeNetworkErrors           MetricSettings `mapstructure:"k8s.node.network.errors"`
	K8sNodeNetworkIo               MetricSettings `mapstructure:"k8s.node.network.io"`
	K8sPodCPUTime                  MetricSettings `mapstructure:"k8s.pod.cpu.time"`
	K8sPodCPUUtilization           MetricSettings `mapstructure:"k8s.pod.cpu.utilization"`
	K8sPodFilesystemAvailable      MetricSettings `mapstructure:"k8s.pod.filesystem.available"`
	K8sPodFilesystemCapacity       MetricSettings `mapstructure:"k8s.pod.filesystem.capacity"`
	K8sPodFilesystemUsage          MetricSettings `mapstructure:"k8s.pod.filesystem.usage"`
	K8sPodMemoryAvailable          MetricSettings `mapstructure:"k8s.pod.memory.available"`
	K8sPodMemoryMajorPageFaults    MetricSettings `mapstructure:"k8s.pod.memory.major_page_faults"`
	K8sPodMemoryPageFaults         MetricSettings `mapstructure:"k8s.pod.memory.page_faults"`
	K8sPodMemoryRss                MetricSettings `mapstructure:"k8s.pod.memory.rss"`
	K8sPodMemoryUsage              MetricSettings `mapstructure:"k8s.pod.memory.usage"`
	K8sPodMemoryWorkingSet         MetricSettings `mapstructure:"k8s.pod.memory.working_set"`
	K8sPodNetworkErrors            MetricSettings `mapstructure:"k8s.pod.network.errors"`
	K8sPodNetworkIo                MetricSettings `mapstructure:"k8s.pod.network.io"`
	K8sVolumeAvailable             MetricSettings `mapstructure:"k8s.volume.available"`
	K8sVolumeCapacity              MetricSettings `mapstructure:"k8s.volume.capacity"`
	K8sVolumeInodes                MetricSettings `mapstructure:"k8s.volume.inodes"`
	K8sVolumeInodesFree            MetricSettings `mapstructure:"k8s.volume.inodes.free"`
	K8sVolumeInodesUsed            MetricSettings `mapstructure:"k8s.volume.inodes.used"`
}

func DefaultMetricsSettings() MetricsSettings {
	return MetricsSettings{
		ContainerCPUTime: MetricSettings{
			Enabled: true,
		},
		ContainerCPUUtilization: MetricSettings{
			Enabled: true,
		},
		ContainerFilesystemAvailable: MetricSettings{
			Enabled: true,
		},
		ContainerFilesystemCapacity: MetricSettings{
			Enabled: true,
		},
		ContainerFilesystemUsage: MetricSettings{
			Enabled: true,
		},
		ContainerMemoryAvailable: MetricSettings{
			Enabled: true,
		},
		ContainerMemoryMajorPageFaults: MetricSettings{
			Enabled: true,
		},
		ContainerMemoryPageFaults: MetricSettings{
			Enabled: true,
		},
		ContainerMemoryRss: MetricSettings{
			Enabled: true,
		},
		ContainerMemoryUsage: MetricSettings{
			Enabled: true,
		},
		ContainerMemoryWorkingSet: MetricSettings{
			Enabled: true,
		},
		K8sNodeCPUTime: MetricSettings{
			Enabled: true,
		},
		K8sNodeCPUUtilization: MetricSettings{
			Enabled: true,
		},
		K8sNodeFilesystemAvailable: MetricSettings{
			Enabled: true,
		},
		K8sNodeFilesystemCapacity: MetricSettings{
			Enabled: true,
		},
		K8sNodeFilesystemUsage: MetricSettings{
			Enabled: true,
		},
		K8sNodeMemoryAvailable: MetricSettings{
			Enabled: true,
		},
		K8sNodeMemoryMajorPageFaults: MetricSettings{
			Enabled: true,
		},
		K8sNodeMemoryPageFaults: MetricSettings{
			Enabled: true,
		},
		K8sNodeMemoryRss: MetricSettings{
			Enabled: true,
		},
		K8sNodeMemoryUsage: MetricSettings{
			Enabled: true,
		},
		K8sNodeMemoryWorkingSet: MetricSettings{
			Enabled: true,
		},
		K8sNodeNetworkErrors: MetricSettings{
			Enabled: true,
		},
		K8sNodeNetworkIo: MetricSettings{
			Enabled: true,
		},
		K8sPodCPUTime: MetricSettings{
			Enabled: true,
		},
		K8sPodCPUUtilization: MetricSettings{
			Enabled: true,
		},
		K8sPodFilesystemAvailable: MetricSettings{
			Enabled: true,
		},
		K8sPodFilesystemCapacity: MetricSettings{
			Enabled: true,
		},
		K8sPodFilesystemUsage: MetricSettings{
			Enabled: true,
		},
		K8sPodMemoryAvailable: MetricSettings{
			Enabled: true,
		},
		K8sPodMemoryMajorPageFaults: MetricSettings{
			Enabled: true,
		},
		K8sPodMemoryPageFaults: MetricSettings{
			Enabled: true,
		},
		K8sPodMemoryRss: MetricSettings{
			Enabled: true,
		},
		K8sPodMemoryUsage: MetricSettings{
			Enabled: true,
		},
		K8sPodMemoryWorkingSet: MetricSettings{
			Enabled: true,
		},
		K8sPodNetworkErrors: MetricSettings{
			Enabled: true,
		},
		K8sPodNetworkIo: MetricSettings{
			Enabled: true,
		},
		K8sVolumeAvailable: MetricSettings{
			Enabled: true,
		},
		K8sVolumeCapacity: MetricSettings{
			Enabled: true,
		},
		K8sVolumeInodes: MetricSettings{
			Enabled: true,
		},
		K8sVolumeInodesFree: MetricSettings{
			Enabled: true,
		},
		K8sVolumeInodesUsed: MetricSettings{
			Enabled: true,
		},
	}
}

// ResourceAttributeSettings provides common settings for a particular metric.
type ResourceAttributeSettings struct {
	Enabled bool `mapstructure:"enabled"`
}

// ResourceAttributesSettings provides settings for kubeletstatsreceiver metrics.
type ResourceAttributesSettings struct {
	AwsVolumeID                  ResourceAttributeSettings `mapstructure:"aws.volume.id"`
	ContainerID                  ResourceAttributeSettings `mapstructure:"container.id"`
	FsType                       ResourceAttributeSettings `mapstructure:"fs.type"`
	GcePdName                    ResourceAttributeSettings `mapstructure:"gce.pd.name"`
	GlusterfsEndpointsName       ResourceAttributeSettings `mapstructure:"glusterfs.endpoints.name"`
	GlusterfsPath                ResourceAttributeSettings `mapstructure:"glusterfs.path"`
	K8sContainerName             ResourceAttributeSettings `mapstructure:"k8s.container.name"`
	K8sNamespaceName             ResourceAttributeSettings `mapstructure:"k8s.namespace.name"`
	K8sNodeName                  ResourceAttributeSettings `mapstructure:"k8s.node.name"`
	K8sPersistentvolumeclaimName ResourceAttributeSettings `mapstructure:"k8s.persistentvolumeclaim.name"`
	K8sPodName                   ResourceAttributeSettings `mapstructure:"k8s.pod.name"`
	K8sPodUID                    ResourceAttributeSettings `mapstructure:"k8s.pod.uid"`
	K8sVolumeName                ResourceAttributeSettings `mapstructure:"k8s.volume.name"`
	K8sVolumeType                ResourceAttributeSettings `mapstructure:"k8s.volume.type"`
	Partition                    ResourceAttributeSettings `mapstructure:"partition"`
}

func DefaultResourceAttributesSettings() ResourceAttributesSettings {
	return ResourceAttributesSettings{
		AwsVolumeID: ResourceAttributeSettings{
			Enabled: true,
		},
		ContainerID: ResourceAttributeSettings{
			Enabled: true,
		},
		FsType: ResourceAttributeSettings{
			Enabled: true,
		},
		GcePdName: ResourceAttributeSettings{
			Enabled: true,
		},
		GlusterfsEndpointsName: ResourceAttributeSettings{
			Enabled: true,
		},
		GlusterfsPath: ResourceAttributeSettings{
			Enabled: true,
		},
		K8sContainerName: ResourceAttributeSettings{
			Enabled: true,
		},
		K8sNamespaceName: ResourceAttributeSettings{
			Enabled: true,
		},
		K8sNodeName: ResourceAttributeSettings{
			Enabled: true,
		},
		K8sPersistentvolumeclaimName: ResourceAttributeSettings{
			Enabled: true,
		},
		K8sPodName: ResourceAttributeSettings{
			Enabled: true,
		},
		K8sPodUID: ResourceAttributeSettings{
			Enabled: true,
		},
		K8sVolumeName: ResourceAttributeSettings{
			Enabled: true,
		},
		K8sVolumeType: ResourceAttributeSettings{
			Enabled: true,
		},
		Partition: ResourceAttributeSettings{
			Enabled: true,
		},
	}
}

// AttributeDirection specifies the a value direction attribute.
type AttributeDirection int

const (
	_ AttributeDirection = iota
	AttributeDirectionReceive
	AttributeDirectionTransmit
)

// String returns the string representation of the AttributeDirection.
func (av AttributeDirection) String() string {
	switch av {
	case AttributeDirectionReceive:
		return "receive"
	case AttributeDirectionTransmit:
		return "transmit"
	}
	return ""
}

// MapAttributeDirection is a helper map of string to AttributeDirection attribute value.
var MapAttributeDirection = map[string]AttributeDirection{
	"receive":  AttributeDirectionReceive,
	"transmit": AttributeDirectionTransmit,
}

type metricContainerCPUTime struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills container.cpu.time metric with initial data.
func (m *metricContainerCPUTime) init() {
	m.data.SetName("container.cpu.time")
	m.data.SetDescription("Container CPU time")
	m.data.SetUnit("s")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricContainerCPUTime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricContainerCPUTime) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricContainerCPUTime) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricContainerCPUTime(settings MetricSettings) metricContainerCPUTime {
	m := metricContainerCPUTime{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricContainerCPUUtilization struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills container.cpu.utilization metric with initial data.
func (m *metricContainerCPUUtilization) init() {
	m.data.SetName("container.cpu.utilization")
	m.data.SetDescription("Container CPU utilization")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricContainerCPUUtilization) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricContainerCPUUtilization) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricContainerCPUUtilization) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricContainerCPUUtilization(settings MetricSettings) metricContainerCPUUtilization {
	m := metricContainerCPUUtilization{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricContainerFilesystemAvailable struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills container.filesystem.available metric with initial data.
func (m *metricContainerFilesystemAvailable) init() {
	m.data.SetName("container.filesystem.available")
	m.data.SetDescription("Container filesystem available")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricContainerFilesystemAvailable) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricContainerFilesystemAvailable) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricContainerFilesystemAvailable) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricContainerFilesystemAvailable(settings MetricSettings) metricContainerFilesystemAvailable {
	m := metricContainerFilesystemAvailable{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricContainerFilesystemCapacity struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills container.filesystem.capacity metric with initial data.
func (m *metricContainerFilesystemCapacity) init() {
	m.data.SetName("container.filesystem.capacity")
	m.data.SetDescription("Container filesystem capacity")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricContainerFilesystemCapacity) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricContainerFilesystemCapacity) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricContainerFilesystemCapacity) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricContainerFilesystemCapacity(settings MetricSettings) metricContainerFilesystemCapacity {
	m := metricContainerFilesystemCapacity{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricContainerFilesystemUsage struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills container.filesystem.usage metric with initial data.
func (m *metricContainerFilesystemUsage) init() {
	m.data.SetName("container.filesystem.usage")
	m.data.SetDescription("Container filesystem usage")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricContainerFilesystemUsage) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricContainerFilesystemUsage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricContainerFilesystemUsage) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricContainerFilesystemUsage(settings MetricSettings) metricContainerFilesystemUsage {
	m := metricContainerFilesystemUsage{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricContainerMemoryAvailable struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills container.memory.available metric with initial data.
func (m *metricContainerMemoryAvailable) init() {
	m.data.SetName("container.memory.available")
	m.data.SetDescription("Container memory available")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricContainerMemoryAvailable) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricContainerMemoryAvailable) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricContainerMemoryAvailable) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricContainerMemoryAvailable(settings MetricSettings) metricContainerMemoryAvailable {
	m := metricContainerMemoryAvailable{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricContainerMemoryMajorPageFaults struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills container.memory.major_page_faults metric with initial data.
func (m *metricContainerMemoryMajorPageFaults) init() {
	m.data.SetName("container.memory.major_page_faults")
	m.data.SetDescription("Container memory major_page_faults")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricContainerMemoryMajorPageFaults) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricContainerMemoryMajorPageFaults) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricContainerMemoryMajorPageFaults) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricContainerMemoryMajorPageFaults(settings MetricSettings) metricContainerMemoryMajorPageFaults {
	m := metricContainerMemoryMajorPageFaults{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricContainerMemoryPageFaults struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills container.memory.page_faults metric with initial data.
func (m *metricContainerMemoryPageFaults) init() {
	m.data.SetName("container.memory.page_faults")
	m.data.SetDescription("Container memory page_faults")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricContainerMemoryPageFaults) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricContainerMemoryPageFaults) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricContainerMemoryPageFaults) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricContainerMemoryPageFaults(settings MetricSettings) metricContainerMemoryPageFaults {
	m := metricContainerMemoryPageFaults{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricContainerMemoryRss struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills container.memory.rss metric with initial data.
func (m *metricContainerMemoryRss) init() {
	m.data.SetName("container.memory.rss")
	m.data.SetDescription("Container memory rss")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricContainerMemoryRss) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricContainerMemoryRss) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricContainerMemoryRss) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricContainerMemoryRss(settings MetricSettings) metricContainerMemoryRss {
	m := metricContainerMemoryRss{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricContainerMemoryUsage struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills container.memory.usage metric with initial data.
func (m *metricContainerMemoryUsage) init() {
	m.data.SetName("container.memory.usage")
	m.data.SetDescription("Container memory usage")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricContainerMemoryUsage) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricContainerMemoryUsage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricContainerMemoryUsage) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricContainerMemoryUsage(settings MetricSettings) metricContainerMemoryUsage {
	m := metricContainerMemoryUsage{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricContainerMemoryWorkingSet struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills container.memory.working_set metric with initial data.
func (m *metricContainerMemoryWorkingSet) init() {
	m.data.SetName("container.memory.working_set")
	m.data.SetDescription("Container memory working_set")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricContainerMemoryWorkingSet) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricContainerMemoryWorkingSet) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricContainerMemoryWorkingSet) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricContainerMemoryWorkingSet(settings MetricSettings) metricContainerMemoryWorkingSet {
	m := metricContainerMemoryWorkingSet{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sNodeCPUTime struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.node.cpu.time metric with initial data.
func (m *metricK8sNodeCPUTime) init() {
	m.data.SetName("k8s.node.cpu.time")
	m.data.SetDescription("Node CPU time")
	m.data.SetUnit("s")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricK8sNodeCPUTime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sNodeCPUTime) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sNodeCPUTime) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sNodeCPUTime(settings MetricSettings) metricK8sNodeCPUTime {
	m := metricK8sNodeCPUTime{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sNodeCPUUtilization struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.node.cpu.utilization metric with initial data.
func (m *metricK8sNodeCPUUtilization) init() {
	m.data.SetName("k8s.node.cpu.utilization")
	m.data.SetDescription("Node CPU utilization")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sNodeCPUUtilization) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sNodeCPUUtilization) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sNodeCPUUtilization) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sNodeCPUUtilization(settings MetricSettings) metricK8sNodeCPUUtilization {
	m := metricK8sNodeCPUUtilization{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sNodeFilesystemAvailable struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.node.filesystem.available metric with initial data.
func (m *metricK8sNodeFilesystemAvailable) init() {
	m.data.SetName("k8s.node.filesystem.available")
	m.data.SetDescription("Node filesystem available")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sNodeFilesystemAvailable) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sNodeFilesystemAvailable) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sNodeFilesystemAvailable) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sNodeFilesystemAvailable(settings MetricSettings) metricK8sNodeFilesystemAvailable {
	m := metricK8sNodeFilesystemAvailable{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sNodeFilesystemCapacity struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.node.filesystem.capacity metric with initial data.
func (m *metricK8sNodeFilesystemCapacity) init() {
	m.data.SetName("k8s.node.filesystem.capacity")
	m.data.SetDescription("Node filesystem capacity")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sNodeFilesystemCapacity) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sNodeFilesystemCapacity) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sNodeFilesystemCapacity) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sNodeFilesystemCapacity(settings MetricSettings) metricK8sNodeFilesystemCapacity {
	m := metricK8sNodeFilesystemCapacity{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sNodeFilesystemUsage struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.node.filesystem.usage metric with initial data.
func (m *metricK8sNodeFilesystemUsage) init() {
	m.data.SetName("k8s.node.filesystem.usage")
	m.data.SetDescription("Node filesystem usage")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sNodeFilesystemUsage) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sNodeFilesystemUsage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sNodeFilesystemUsage) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sNodeFilesystemUsage(settings MetricSettings) metricK8sNodeFilesystemUsage {
	m := metricK8sNodeFilesystemUsage{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sNodeMemoryAvailable struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.node.memory.available metric with initial data.
func (m *metricK8sNodeMemoryAvailable) init() {
	m.data.SetName("k8s.node.memory.available")
	m.data.SetDescription("Node memory available")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sNodeMemoryAvailable) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sNodeMemoryAvailable) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sNodeMemoryAvailable) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sNodeMemoryAvailable(settings MetricSettings) metricK8sNodeMemoryAvailable {
	m := metricK8sNodeMemoryAvailable{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sNodeMemoryMajorPageFaults struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.node.memory.major_page_faults metric with initial data.
func (m *metricK8sNodeMemoryMajorPageFaults) init() {
	m.data.SetName("k8s.node.memory.major_page_faults")
	m.data.SetDescription("Node memory major_page_faults")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sNodeMemoryMajorPageFaults) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sNodeMemoryMajorPageFaults) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sNodeMemoryMajorPageFaults) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sNodeMemoryMajorPageFaults(settings MetricSettings) metricK8sNodeMemoryMajorPageFaults {
	m := metricK8sNodeMemoryMajorPageFaults{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sNodeMemoryPageFaults struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.node.memory.page_faults metric with initial data.
func (m *metricK8sNodeMemoryPageFaults) init() {
	m.data.SetName("k8s.node.memory.page_faults")
	m.data.SetDescription("Node memory page_faults")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sNodeMemoryPageFaults) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sNodeMemoryPageFaults) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sNodeMemoryPageFaults) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sNodeMemoryPageFaults(settings MetricSettings) metricK8sNodeMemoryPageFaults {
	m := metricK8sNodeMemoryPageFaults{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sNodeMemoryRss struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.node.memory.rss metric with initial data.
func (m *metricK8sNodeMemoryRss) init() {
	m.data.SetName("k8s.node.memory.rss")
	m.data.SetDescription("Node memory rss")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sNodeMemoryRss) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sNodeMemoryRss) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sNodeMemoryRss) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sNodeMemoryRss(settings MetricSettings) metricK8sNodeMemoryRss {
	m := metricK8sNodeMemoryRss{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sNodeMemoryUsage struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.node.memory.usage metric with initial data.
func (m *metricK8sNodeMemoryUsage) init() {
	m.data.SetName("k8s.node.memory.usage")
	m.data.SetDescription("Node memory usage")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sNodeMemoryUsage) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sNodeMemoryUsage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sNodeMemoryUsage) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sNodeMemoryUsage(settings MetricSettings) metricK8sNodeMemoryUsage {
	m := metricK8sNodeMemoryUsage{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sNodeMemoryWorkingSet struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.node.memory.working_set metric with initial data.
func (m *metricK8sNodeMemoryWorkingSet) init() {
	m.data.SetName("k8s.node.memory.working_set")
	m.data.SetDescription("Node memory working_set")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sNodeMemoryWorkingSet) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sNodeMemoryWorkingSet) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sNodeMemoryWorkingSet) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sNodeMemoryWorkingSet(settings MetricSettings) metricK8sNodeMemoryWorkingSet {
	m := metricK8sNodeMemoryWorkingSet{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sNodeNetworkErrors struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.node.network.errors metric with initial data.
func (m *metricK8sNodeNetworkErrors) init() {
	m.data.SetName("k8s.node.network.errors")
	m.data.SetDescription("Node network errors")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricK8sNodeNetworkErrors) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, interfaceAttributeValue string, directionAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("interface", interfaceAttributeValue)
	dp.Attributes().PutStr("direction", directionAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sNodeNetworkErrors) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sNodeNetworkErrors) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sNodeNetworkErrors(settings MetricSettings) metricK8sNodeNetworkErrors {
	m := metricK8sNodeNetworkErrors{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sNodeNetworkIo struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.node.network.io metric with initial data.
func (m *metricK8sNodeNetworkIo) init() {
	m.data.SetName("k8s.node.network.io")
	m.data.SetDescription("Node network IO")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricK8sNodeNetworkIo) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, interfaceAttributeValue string, directionAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("interface", interfaceAttributeValue)
	dp.Attributes().PutStr("direction", directionAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sNodeNetworkIo) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sNodeNetworkIo) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sNodeNetworkIo(settings MetricSettings) metricK8sNodeNetworkIo {
	m := metricK8sNodeNetworkIo{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sPodCPUTime struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.pod.cpu.time metric with initial data.
func (m *metricK8sPodCPUTime) init() {
	m.data.SetName("k8s.pod.cpu.time")
	m.data.SetDescription("Pod CPU time")
	m.data.SetUnit("s")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricK8sPodCPUTime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sPodCPUTime) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sPodCPUTime) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sPodCPUTime(settings MetricSettings) metricK8sPodCPUTime {
	m := metricK8sPodCPUTime{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sPodCPUUtilization struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.pod.cpu.utilization metric with initial data.
func (m *metricK8sPodCPUUtilization) init() {
	m.data.SetName("k8s.pod.cpu.utilization")
	m.data.SetDescription("Pod CPU utilization")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sPodCPUUtilization) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sPodCPUUtilization) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sPodCPUUtilization) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sPodCPUUtilization(settings MetricSettings) metricK8sPodCPUUtilization {
	m := metricK8sPodCPUUtilization{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sPodFilesystemAvailable struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.pod.filesystem.available metric with initial data.
func (m *metricK8sPodFilesystemAvailable) init() {
	m.data.SetName("k8s.pod.filesystem.available")
	m.data.SetDescription("Pod filesystem available")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sPodFilesystemAvailable) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sPodFilesystemAvailable) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sPodFilesystemAvailable) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sPodFilesystemAvailable(settings MetricSettings) metricK8sPodFilesystemAvailable {
	m := metricK8sPodFilesystemAvailable{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sPodFilesystemCapacity struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.pod.filesystem.capacity metric with initial data.
func (m *metricK8sPodFilesystemCapacity) init() {
	m.data.SetName("k8s.pod.filesystem.capacity")
	m.data.SetDescription("Pod filesystem capacity")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sPodFilesystemCapacity) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sPodFilesystemCapacity) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sPodFilesystemCapacity) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sPodFilesystemCapacity(settings MetricSettings) metricK8sPodFilesystemCapacity {
	m := metricK8sPodFilesystemCapacity{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sPodFilesystemUsage struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.pod.filesystem.usage metric with initial data.
func (m *metricK8sPodFilesystemUsage) init() {
	m.data.SetName("k8s.pod.filesystem.usage")
	m.data.SetDescription("Pod filesystem usage")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sPodFilesystemUsage) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sPodFilesystemUsage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sPodFilesystemUsage) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sPodFilesystemUsage(settings MetricSettings) metricK8sPodFilesystemUsage {
	m := metricK8sPodFilesystemUsage{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sPodMemoryAvailable struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.pod.memory.available metric with initial data.
func (m *metricK8sPodMemoryAvailable) init() {
	m.data.SetName("k8s.pod.memory.available")
	m.data.SetDescription("Pod memory available")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sPodMemoryAvailable) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sPodMemoryAvailable) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sPodMemoryAvailable) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sPodMemoryAvailable(settings MetricSettings) metricK8sPodMemoryAvailable {
	m := metricK8sPodMemoryAvailable{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sPodMemoryMajorPageFaults struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.pod.memory.major_page_faults metric with initial data.
func (m *metricK8sPodMemoryMajorPageFaults) init() {
	m.data.SetName("k8s.pod.memory.major_page_faults")
	m.data.SetDescription("Pod memory major_page_faults")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sPodMemoryMajorPageFaults) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sPodMemoryMajorPageFaults) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sPodMemoryMajorPageFaults) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sPodMemoryMajorPageFaults(settings MetricSettings) metricK8sPodMemoryMajorPageFaults {
	m := metricK8sPodMemoryMajorPageFaults{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sPodMemoryPageFaults struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.pod.memory.page_faults metric with initial data.
func (m *metricK8sPodMemoryPageFaults) init() {
	m.data.SetName("k8s.pod.memory.page_faults")
	m.data.SetDescription("Pod memory page_faults")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sPodMemoryPageFaults) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sPodMemoryPageFaults) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sPodMemoryPageFaults) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sPodMemoryPageFaults(settings MetricSettings) metricK8sPodMemoryPageFaults {
	m := metricK8sPodMemoryPageFaults{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sPodMemoryRss struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.pod.memory.rss metric with initial data.
func (m *metricK8sPodMemoryRss) init() {
	m.data.SetName("k8s.pod.memory.rss")
	m.data.SetDescription("Pod memory rss")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sPodMemoryRss) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sPodMemoryRss) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sPodMemoryRss) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sPodMemoryRss(settings MetricSettings) metricK8sPodMemoryRss {
	m := metricK8sPodMemoryRss{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sPodMemoryUsage struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.pod.memory.usage metric with initial data.
func (m *metricK8sPodMemoryUsage) init() {
	m.data.SetName("k8s.pod.memory.usage")
	m.data.SetDescription("Pod memory usage")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sPodMemoryUsage) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sPodMemoryUsage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sPodMemoryUsage) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sPodMemoryUsage(settings MetricSettings) metricK8sPodMemoryUsage {
	m := metricK8sPodMemoryUsage{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sPodMemoryWorkingSet struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.pod.memory.working_set metric with initial data.
func (m *metricK8sPodMemoryWorkingSet) init() {
	m.data.SetName("k8s.pod.memory.working_set")
	m.data.SetDescription("Pod memory working_set")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sPodMemoryWorkingSet) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sPodMemoryWorkingSet) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sPodMemoryWorkingSet) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sPodMemoryWorkingSet(settings MetricSettings) metricK8sPodMemoryWorkingSet {
	m := metricK8sPodMemoryWorkingSet{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sPodNetworkErrors struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.pod.network.errors metric with initial data.
func (m *metricK8sPodNetworkErrors) init() {
	m.data.SetName("k8s.pod.network.errors")
	m.data.SetDescription("Pod network errors")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricK8sPodNetworkErrors) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, interfaceAttributeValue string, directionAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("interface", interfaceAttributeValue)
	dp.Attributes().PutStr("direction", directionAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sPodNetworkErrors) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sPodNetworkErrors) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sPodNetworkErrors(settings MetricSettings) metricK8sPodNetworkErrors {
	m := metricK8sPodNetworkErrors{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sPodNetworkIo struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.pod.network.io metric with initial data.
func (m *metricK8sPodNetworkIo) init() {
	m.data.SetName("k8s.pod.network.io")
	m.data.SetDescription("Pod network IO")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricK8sPodNetworkIo) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, interfaceAttributeValue string, directionAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("interface", interfaceAttributeValue)
	dp.Attributes().PutStr("direction", directionAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sPodNetworkIo) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sPodNetworkIo) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sPodNetworkIo(settings MetricSettings) metricK8sPodNetworkIo {
	m := metricK8sPodNetworkIo{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sVolumeAvailable struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.volume.available metric with initial data.
func (m *metricK8sVolumeAvailable) init() {
	m.data.SetName("k8s.volume.available")
	m.data.SetDescription("The number of available bytes in the volume.")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sVolumeAvailable) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sVolumeAvailable) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sVolumeAvailable) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sVolumeAvailable(settings MetricSettings) metricK8sVolumeAvailable {
	m := metricK8sVolumeAvailable{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sVolumeCapacity struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.volume.capacity metric with initial data.
func (m *metricK8sVolumeCapacity) init() {
	m.data.SetName("k8s.volume.capacity")
	m.data.SetDescription("The total capacity in bytes of the volume.")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sVolumeCapacity) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sVolumeCapacity) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sVolumeCapacity) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sVolumeCapacity(settings MetricSettings) metricK8sVolumeCapacity {
	m := metricK8sVolumeCapacity{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sVolumeInodes struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.volume.inodes metric with initial data.
func (m *metricK8sVolumeInodes) init() {
	m.data.SetName("k8s.volume.inodes")
	m.data.SetDescription("The total inodes in the filesystem.")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sVolumeInodes) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sVolumeInodes) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sVolumeInodes) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sVolumeInodes(settings MetricSettings) metricK8sVolumeInodes {
	m := metricK8sVolumeInodes{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sVolumeInodesFree struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.volume.inodes.free metric with initial data.
func (m *metricK8sVolumeInodesFree) init() {
	m.data.SetName("k8s.volume.inodes.free")
	m.data.SetDescription("The free inodes in the filesystem.")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sVolumeInodesFree) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sVolumeInodesFree) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sVolumeInodesFree) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sVolumeInodesFree(settings MetricSettings) metricK8sVolumeInodesFree {
	m := metricK8sVolumeInodesFree{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sVolumeInodesUsed struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.volume.inodes.used metric with initial data.
func (m *metricK8sVolumeInodesUsed) init() {
	m.data.SetName("k8s.volume.inodes.used")
	m.data.SetDescription("The inodes used by the filesystem. This may not equal inodes - free because filesystem may share inodes with other filesystems.")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sVolumeInodesUsed) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sVolumeInodesUsed) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sVolumeInodesUsed) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sVolumeInodesUsed(settings MetricSettings) metricK8sVolumeInodesUsed {
	m := metricK8sVolumeInodesUsed{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

// MetricsBuilderConfig is a structural subset of an otherwise 1-1 copy of metadata.yaml
type MetricsBuilderConfig struct {
	Metrics            MetricsSettings            `mapstructure:"metrics"`
	ResourceAttributes ResourceAttributesSettings `mapstructure:"resource_attributes"`
}

// MetricsBuilder provides an interface for scrapers to report metrics while taking care of all the transformations
// required to produce metric representation defined in metadata and user settings.
type MetricsBuilder struct {
	startTime                            pcommon.Timestamp   // start time that will be applied to all recorded data points.
	metricsCapacity                      int                 // maximum observed number of metrics per resource.
	resourceCapacity                     int                 // maximum observed number of resource attributes.
	metricsBuffer                        pmetric.Metrics     // accumulates metrics data before emitting.
	buildInfo                            component.BuildInfo // contains version information
	resourceAttributesSettings           ResourceAttributesSettings
	metricContainerCPUTime               metricContainerCPUTime
	metricContainerCPUUtilization        metricContainerCPUUtilization
	metricContainerFilesystemAvailable   metricContainerFilesystemAvailable
	metricContainerFilesystemCapacity    metricContainerFilesystemCapacity
	metricContainerFilesystemUsage       metricContainerFilesystemUsage
	metricContainerMemoryAvailable       metricContainerMemoryAvailable
	metricContainerMemoryMajorPageFaults metricContainerMemoryMajorPageFaults
	metricContainerMemoryPageFaults      metricContainerMemoryPageFaults
	metricContainerMemoryRss             metricContainerMemoryRss
	metricContainerMemoryUsage           metricContainerMemoryUsage
	metricContainerMemoryWorkingSet      metricContainerMemoryWorkingSet
	metricK8sNodeCPUTime                 metricK8sNodeCPUTime
	metricK8sNodeCPUUtilization          metricK8sNodeCPUUtilization
	metricK8sNodeFilesystemAvailable     metricK8sNodeFilesystemAvailable
	metricK8sNodeFilesystemCapacity      metricK8sNodeFilesystemCapacity
	metricK8sNodeFilesystemUsage         metricK8sNodeFilesystemUsage
	metricK8sNodeMemoryAvailable         metricK8sNodeMemoryAvailable
	metricK8sNodeMemoryMajorPageFaults   metricK8sNodeMemoryMajorPageFaults
	metricK8sNodeMemoryPageFaults        metricK8sNodeMemoryPageFaults
	metricK8sNodeMemoryRss               metricK8sNodeMemoryRss
	metricK8sNodeMemoryUsage             metricK8sNodeMemoryUsage
	metricK8sNodeMemoryWorkingSet        metricK8sNodeMemoryWorkingSet
	metricK8sNodeNetworkErrors           metricK8sNodeNetworkErrors
	metricK8sNodeNetworkIo               metricK8sNodeNetworkIo
	metricK8sPodCPUTime                  metricK8sPodCPUTime
	metricK8sPodCPUUtilization           metricK8sPodCPUUtilization
	metricK8sPodFilesystemAvailable      metricK8sPodFilesystemAvailable
	metricK8sPodFilesystemCapacity       metricK8sPodFilesystemCapacity
	metricK8sPodFilesystemUsage          metricK8sPodFilesystemUsage
	metricK8sPodMemoryAvailable          metricK8sPodMemoryAvailable
	metricK8sPodMemoryMajorPageFaults    metricK8sPodMemoryMajorPageFaults
	metricK8sPodMemoryPageFaults         metricK8sPodMemoryPageFaults
	metricK8sPodMemoryRss                metricK8sPodMemoryRss
	metricK8sPodMemoryUsage              metricK8sPodMemoryUsage
	metricK8sPodMemoryWorkingSet         metricK8sPodMemoryWorkingSet
	metricK8sPodNetworkErrors            metricK8sPodNetworkErrors
	metricK8sPodNetworkIo                metricK8sPodNetworkIo
	metricK8sVolumeAvailable             metricK8sVolumeAvailable
	metricK8sVolumeCapacity              metricK8sVolumeCapacity
	metricK8sVolumeInodes                metricK8sVolumeInodes
	metricK8sVolumeInodesFree            metricK8sVolumeInodesFree
	metricK8sVolumeInodesUsed            metricK8sVolumeInodesUsed
}

// metricBuilderOption applies changes to default metrics builder.
type metricBuilderOption func(*MetricsBuilder)

// WithStartTime sets startTime on the metrics builder.
func WithStartTime(startTime pcommon.Timestamp) metricBuilderOption {
	return func(mb *MetricsBuilder) {
		mb.startTime = startTime
	}
}

func DefaultMetricsBuilderConfig() MetricsBuilderConfig {
	return MetricsBuilderConfig{
		Metrics:            DefaultMetricsSettings(),
		ResourceAttributes: DefaultResourceAttributesSettings(),
	}
}

func NewMetricsBuilderConfig(ms MetricsSettings, ras ResourceAttributesSettings) MetricsBuilderConfig {
	return MetricsBuilderConfig{
		Metrics:            ms,
		ResourceAttributes: ras,
	}
}

func NewMetricsBuilder(mbc MetricsBuilderConfig, settings receiver.CreateSettings, options ...metricBuilderOption) *MetricsBuilder {
	mb := &MetricsBuilder{
		startTime:                            pcommon.NewTimestampFromTime(time.Now()),
		metricsBuffer:                        pmetric.NewMetrics(),
		buildInfo:                            settings.BuildInfo,
		resourceAttributesSettings:           mbc.ResourceAttributes,
		metricContainerCPUTime:               newMetricContainerCPUTime(mbc.Metrics.ContainerCPUTime),
		metricContainerCPUUtilization:        newMetricContainerCPUUtilization(mbc.Metrics.ContainerCPUUtilization),
		metricContainerFilesystemAvailable:   newMetricContainerFilesystemAvailable(mbc.Metrics.ContainerFilesystemAvailable),
		metricContainerFilesystemCapacity:    newMetricContainerFilesystemCapacity(mbc.Metrics.ContainerFilesystemCapacity),
		metricContainerFilesystemUsage:       newMetricContainerFilesystemUsage(mbc.Metrics.ContainerFilesystemUsage),
		metricContainerMemoryAvailable:       newMetricContainerMemoryAvailable(mbc.Metrics.ContainerMemoryAvailable),
		metricContainerMemoryMajorPageFaults: newMetricContainerMemoryMajorPageFaults(mbc.Metrics.ContainerMemoryMajorPageFaults),
		metricContainerMemoryPageFaults:      newMetricContainerMemoryPageFaults(mbc.Metrics.ContainerMemoryPageFaults),
		metricContainerMemoryRss:             newMetricContainerMemoryRss(mbc.Metrics.ContainerMemoryRss),
		metricContainerMemoryUsage:           newMetricContainerMemoryUsage(mbc.Metrics.ContainerMemoryUsage),
		metricContainerMemoryWorkingSet:      newMetricContainerMemoryWorkingSet(mbc.Metrics.ContainerMemoryWorkingSet),
		metricK8sNodeCPUTime:                 newMetricK8sNodeCPUTime(mbc.Metrics.K8sNodeCPUTime),
		metricK8sNodeCPUUtilization:          newMetricK8sNodeCPUUtilization(mbc.Metrics.K8sNodeCPUUtilization),
		metricK8sNodeFilesystemAvailable:     newMetricK8sNodeFilesystemAvailable(mbc.Metrics.K8sNodeFilesystemAvailable),
		metricK8sNodeFilesystemCapacity:      newMetricK8sNodeFilesystemCapacity(mbc.Metrics.K8sNodeFilesystemCapacity),
		metricK8sNodeFilesystemUsage:         newMetricK8sNodeFilesystemUsage(mbc.Metrics.K8sNodeFilesystemUsage),
		metricK8sNodeMemoryAvailable:         newMetricK8sNodeMemoryAvailable(mbc.Metrics.K8sNodeMemoryAvailable),
		metricK8sNodeMemoryMajorPageFaults:   newMetricK8sNodeMemoryMajorPageFaults(mbc.Metrics.K8sNodeMemoryMajorPageFaults),
		metricK8sNodeMemoryPageFaults:        newMetricK8sNodeMemoryPageFaults(mbc.Metrics.K8sNodeMemoryPageFaults),
		metricK8sNodeMemoryRss:               newMetricK8sNodeMemoryRss(mbc.Metrics.K8sNodeMemoryRss),
		metricK8sNodeMemoryUsage:             newMetricK8sNodeMemoryUsage(mbc.Metrics.K8sNodeMemoryUsage),
		metricK8sNodeMemoryWorkingSet:        newMetricK8sNodeMemoryWorkingSet(mbc.Metrics.K8sNodeMemoryWorkingSet),
		metricK8sNodeNetworkErrors:           newMetricK8sNodeNetworkErrors(mbc.Metrics.K8sNodeNetworkErrors),
		metricK8sNodeNetworkIo:               newMetricK8sNodeNetworkIo(mbc.Metrics.K8sNodeNetworkIo),
		metricK8sPodCPUTime:                  newMetricK8sPodCPUTime(mbc.Metrics.K8sPodCPUTime),
		metricK8sPodCPUUtilization:           newMetricK8sPodCPUUtilization(mbc.Metrics.K8sPodCPUUtilization),
		metricK8sPodFilesystemAvailable:      newMetricK8sPodFilesystemAvailable(mbc.Metrics.K8sPodFilesystemAvailable),
		metricK8sPodFilesystemCapacity:       newMetricK8sPodFilesystemCapacity(mbc.Metrics.K8sPodFilesystemCapacity),
		metricK8sPodFilesystemUsage:          newMetricK8sPodFilesystemUsage(mbc.Metrics.K8sPodFilesystemUsage),
		metricK8sPodMemoryAvailable:          newMetricK8sPodMemoryAvailable(mbc.Metrics.K8sPodMemoryAvailable),
		metricK8sPodMemoryMajorPageFaults:    newMetricK8sPodMemoryMajorPageFaults(mbc.Metrics.K8sPodMemoryMajorPageFaults),
		metricK8sPodMemoryPageFaults:         newMetricK8sPodMemoryPageFaults(mbc.Metrics.K8sPodMemoryPageFaults),
		metricK8sPodMemoryRss:                newMetricK8sPodMemoryRss(mbc.Metrics.K8sPodMemoryRss),
		metricK8sPodMemoryUsage:              newMetricK8sPodMemoryUsage(mbc.Metrics.K8sPodMemoryUsage),
		metricK8sPodMemoryWorkingSet:         newMetricK8sPodMemoryWorkingSet(mbc.Metrics.K8sPodMemoryWorkingSet),
		metricK8sPodNetworkErrors:            newMetricK8sPodNetworkErrors(mbc.Metrics.K8sPodNetworkErrors),
		metricK8sPodNetworkIo:                newMetricK8sPodNetworkIo(mbc.Metrics.K8sPodNetworkIo),
		metricK8sVolumeAvailable:             newMetricK8sVolumeAvailable(mbc.Metrics.K8sVolumeAvailable),
		metricK8sVolumeCapacity:              newMetricK8sVolumeCapacity(mbc.Metrics.K8sVolumeCapacity),
		metricK8sVolumeInodes:                newMetricK8sVolumeInodes(mbc.Metrics.K8sVolumeInodes),
		metricK8sVolumeInodesFree:            newMetricK8sVolumeInodesFree(mbc.Metrics.K8sVolumeInodesFree),
		metricK8sVolumeInodesUsed:            newMetricK8sVolumeInodesUsed(mbc.Metrics.K8sVolumeInodesUsed),
	}
	for _, op := range options {
		op(mb)
	}
	return mb
}

// updateCapacity updates max length of metrics and resource attributes that will be used for the slice capacity.
func (mb *MetricsBuilder) updateCapacity(rm pmetric.ResourceMetrics) {
	if mb.metricsCapacity < rm.ScopeMetrics().At(0).Metrics().Len() {
		mb.metricsCapacity = rm.ScopeMetrics().At(0).Metrics().Len()
	}
	if mb.resourceCapacity < rm.Resource().Attributes().Len() {
		mb.resourceCapacity = rm.Resource().Attributes().Len()
	}
}

// ResourceMetricsOption applies changes to provided resource metrics.
type ResourceMetricsOption func(ResourceAttributesSettings, pmetric.ResourceMetrics)

// WithAwsVolumeID sets provided value as "aws.volume.id" attribute for current resource.
func WithAwsVolumeID(val string) ResourceMetricsOption {
	return func(ras ResourceAttributesSettings, rm pmetric.ResourceMetrics) {
		if ras.AwsVolumeID.Enabled {
			rm.Resource().Attributes().PutStr("aws.volume.id", val)
		}
	}
}

// WithContainerID sets provided value as "container.id" attribute for current resource.
func WithContainerID(val string) ResourceMetricsOption {
	return func(ras ResourceAttributesSettings, rm pmetric.ResourceMetrics) {
		if ras.ContainerID.Enabled {
			rm.Resource().Attributes().PutStr("container.id", val)
		}
	}
}

// WithFsType sets provided value as "fs.type" attribute for current resource.
func WithFsType(val string) ResourceMetricsOption {
	return func(ras ResourceAttributesSettings, rm pmetric.ResourceMetrics) {
		if ras.FsType.Enabled {
			rm.Resource().Attributes().PutStr("fs.type", val)
		}
	}
}

// WithGcePdName sets provided value as "gce.pd.name" attribute for current resource.
func WithGcePdName(val string) ResourceMetricsOption {
	return func(ras ResourceAttributesSettings, rm pmetric.ResourceMetrics) {
		if ras.GcePdName.Enabled {
			rm.Resource().Attributes().PutStr("gce.pd.name", val)
		}
	}
}

// WithGlusterfsEndpointsName sets provided value as "glusterfs.endpoints.name" attribute for current resource.
func WithGlusterfsEndpointsName(val string) ResourceMetricsOption {
	return func(ras ResourceAttributesSettings, rm pmetric.ResourceMetrics) {
		if ras.GlusterfsEndpointsName.Enabled {
			rm.Resource().Attributes().PutStr("glusterfs.endpoints.name", val)
		}
	}
}

// WithGlusterfsPath sets provided value as "glusterfs.path" attribute for current resource.
func WithGlusterfsPath(val string) ResourceMetricsOption {
	return func(ras ResourceAttributesSettings, rm pmetric.ResourceMetrics) {
		if ras.GlusterfsPath.Enabled {
			rm.Resource().Attributes().PutStr("glusterfs.path", val)
		}
	}
}

// WithK8sContainerName sets provided value as "k8s.container.name" attribute for current resource.
func WithK8sContainerName(val string) ResourceMetricsOption {
	return func(ras ResourceAttributesSettings, rm pmetric.ResourceMetrics) {
		if ras.K8sContainerName.Enabled {
			rm.Resource().Attributes().PutStr("k8s.container.name", val)
		}
	}
}

// WithK8sNamespaceName sets provided value as "k8s.namespace.name" attribute for current resource.
func WithK8sNamespaceName(val string) ResourceMetricsOption {
	return func(ras ResourceAttributesSettings, rm pmetric.ResourceMetrics) {
		if ras.K8sNamespaceName.Enabled {
			rm.Resource().Attributes().PutStr("k8s.namespace.name", val)
		}
	}
}

// WithK8sNodeName sets provided value as "k8s.node.name" attribute for current resource.
func WithK8sNodeName(val string) ResourceMetricsOption {
	return func(ras ResourceAttributesSettings, rm pmetric.ResourceMetrics) {
		if ras.K8sNodeName.Enabled {
			rm.Resource().Attributes().PutStr("k8s.node.name", val)
		}
	}
}

// WithK8sPersistentvolumeclaimName sets provided value as "k8s.persistentvolumeclaim.name" attribute for current resource.
func WithK8sPersistentvolumeclaimName(val string) ResourceMetricsOption {
	return func(ras ResourceAttributesSettings, rm pmetric.ResourceMetrics) {
		if ras.K8sPersistentvolumeclaimName.Enabled {
			rm.Resource().Attributes().PutStr("k8s.persistentvolumeclaim.name", val)
		}
	}
}

// WithK8sPodName sets provided value as "k8s.pod.name" attribute for current resource.
func WithK8sPodName(val string) ResourceMetricsOption {
	return func(ras ResourceAttributesSettings, rm pmetric.ResourceMetrics) {
		if ras.K8sPodName.Enabled {
			rm.Resource().Attributes().PutStr("k8s.pod.name", val)
		}
	}
}

// WithK8sPodUID sets provided value as "k8s.pod.uid" attribute for current resource.
func WithK8sPodUID(val string) ResourceMetricsOption {
	return func(ras ResourceAttributesSettings, rm pmetric.ResourceMetrics) {
		if ras.K8sPodUID.Enabled {
			rm.Resource().Attributes().PutStr("k8s.pod.uid", val)
		}
	}
}

// WithK8sVolumeName sets provided value as "k8s.volume.name" attribute for current resource.
func WithK8sVolumeName(val string) ResourceMetricsOption {
	return func(ras ResourceAttributesSettings, rm pmetric.ResourceMetrics) {
		if ras.K8sVolumeName.Enabled {
			rm.Resource().Attributes().PutStr("k8s.volume.name", val)
		}
	}
}

// WithK8sVolumeType sets provided value as "k8s.volume.type" attribute for current resource.
func WithK8sVolumeType(val string) ResourceMetricsOption {
	return func(ras ResourceAttributesSettings, rm pmetric.ResourceMetrics) {
		if ras.K8sVolumeType.Enabled {
			rm.Resource().Attributes().PutStr("k8s.volume.type", val)
		}
	}
}

// WithPartition sets provided value as "partition" attribute for current resource.
func WithPartition(val string) ResourceMetricsOption {
	return func(ras ResourceAttributesSettings, rm pmetric.ResourceMetrics) {
		if ras.Partition.Enabled {
			rm.Resource().Attributes().PutStr("partition", val)
		}
	}
}

// WithStartTimeOverride overrides start time for all the resource metrics data points.
// This option should be only used if different start time has to be set on metrics coming from different resources.
func WithStartTimeOverride(start pcommon.Timestamp) ResourceMetricsOption {
	return func(ras ResourceAttributesSettings, rm pmetric.ResourceMetrics) {
		var dps pmetric.NumberDataPointSlice
		metrics := rm.ScopeMetrics().At(0).Metrics()
		for i := 0; i < metrics.Len(); i++ {
			switch metrics.At(i).Type() {
			case pmetric.MetricTypeGauge:
				dps = metrics.At(i).Gauge().DataPoints()
			case pmetric.MetricTypeSum:
				dps = metrics.At(i).Sum().DataPoints()
			}
			for j := 0; j < dps.Len(); j++ {
				dps.At(j).SetStartTimestamp(start)
			}
		}
	}
}

// EmitForResource saves all the generated metrics under a new resource and updates the internal state to be ready for
// recording another set of data points as part of another resource. This function can be helpful when one scraper
// needs to emit metrics from several resources. Otherwise calling this function is not required,
// just `Emit` function can be called instead.
// Resource attributes should be provided as ResourceMetricsOption arguments.
func (mb *MetricsBuilder) EmitForResource(rmo ...ResourceMetricsOption) {
	rm := pmetric.NewResourceMetrics()
	rm.Resource().Attributes().EnsureCapacity(mb.resourceCapacity)
	ils := rm.ScopeMetrics().AppendEmpty()
	ils.Scope().SetName("otelcol/kubeletstatsreceiver")
	ils.Scope().SetVersion(mb.buildInfo.Version)
	ils.Metrics().EnsureCapacity(mb.metricsCapacity)
	mb.metricContainerCPUTime.emit(ils.Metrics())
	mb.metricContainerCPUUtilization.emit(ils.Metrics())
	mb.metricContainerFilesystemAvailable.emit(ils.Metrics())
	mb.metricContainerFilesystemCapacity.emit(ils.Metrics())
	mb.metricContainerFilesystemUsage.emit(ils.Metrics())
	mb.metricContainerMemoryAvailable.emit(ils.Metrics())
	mb.metricContainerMemoryMajorPageFaults.emit(ils.Metrics())
	mb.metricContainerMemoryPageFaults.emit(ils.Metrics())
	mb.metricContainerMemoryRss.emit(ils.Metrics())
	mb.metricContainerMemoryUsage.emit(ils.Metrics())
	mb.metricContainerMemoryWorkingSet.emit(ils.Metrics())
	mb.metricK8sNodeCPUTime.emit(ils.Metrics())
	mb.metricK8sNodeCPUUtilization.emit(ils.Metrics())
	mb.metricK8sNodeFilesystemAvailable.emit(ils.Metrics())
	mb.metricK8sNodeFilesystemCapacity.emit(ils.Metrics())
	mb.metricK8sNodeFilesystemUsage.emit(ils.Metrics())
	mb.metricK8sNodeMemoryAvailable.emit(ils.Metrics())
	mb.metricK8sNodeMemoryMajorPageFaults.emit(ils.Metrics())
	mb.metricK8sNodeMemoryPageFaults.emit(ils.Metrics())
	mb.metricK8sNodeMemoryRss.emit(ils.Metrics())
	mb.metricK8sNodeMemoryUsage.emit(ils.Metrics())
	mb.metricK8sNodeMemoryWorkingSet.emit(ils.Metrics())
	mb.metricK8sNodeNetworkErrors.emit(ils.Metrics())
	mb.metricK8sNodeNetworkIo.emit(ils.Metrics())
	mb.metricK8sPodCPUTime.emit(ils.Metrics())
	mb.metricK8sPodCPUUtilization.emit(ils.Metrics())
	mb.metricK8sPodFilesystemAvailable.emit(ils.Metrics())
	mb.metricK8sPodFilesystemCapacity.emit(ils.Metrics())
	mb.metricK8sPodFilesystemUsage.emit(ils.Metrics())
	mb.metricK8sPodMemoryAvailable.emit(ils.Metrics())
	mb.metricK8sPodMemoryMajorPageFaults.emit(ils.Metrics())
	mb.metricK8sPodMemoryPageFaults.emit(ils.Metrics())
	mb.metricK8sPodMemoryRss.emit(ils.Metrics())
	mb.metricK8sPodMemoryUsage.emit(ils.Metrics())
	mb.metricK8sPodMemoryWorkingSet.emit(ils.Metrics())
	mb.metricK8sPodNetworkErrors.emit(ils.Metrics())
	mb.metricK8sPodNetworkIo.emit(ils.Metrics())
	mb.metricK8sVolumeAvailable.emit(ils.Metrics())
	mb.metricK8sVolumeCapacity.emit(ils.Metrics())
	mb.metricK8sVolumeInodes.emit(ils.Metrics())
	mb.metricK8sVolumeInodesFree.emit(ils.Metrics())
	mb.metricK8sVolumeInodesUsed.emit(ils.Metrics())

	for _, op := range rmo {
		op(mb.resourceAttributesSettings, rm)
	}
	if ils.Metrics().Len() > 0 {
		mb.updateCapacity(rm)
		rm.MoveTo(mb.metricsBuffer.ResourceMetrics().AppendEmpty())
	}
}

// Emit returns all the metrics accumulated by the metrics builder and updates the internal state to be ready for
// recording another set of metrics. This function will be responsible for applying all the transformations required to
// produce metric representation defined in metadata and user settings, e.g. delta or cumulative.
func (mb *MetricsBuilder) Emit(rmo ...ResourceMetricsOption) pmetric.Metrics {
	mb.EmitForResource(rmo...)
	metrics := mb.metricsBuffer
	mb.metricsBuffer = pmetric.NewMetrics()
	return metrics
}

// RecordContainerCPUTimeDataPoint adds a data point to container.cpu.time metric.
func (mb *MetricsBuilder) RecordContainerCPUTimeDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricContainerCPUTime.recordDataPoint(mb.startTime, ts, val)
}

// RecordContainerCPUUtilizationDataPoint adds a data point to container.cpu.utilization metric.
func (mb *MetricsBuilder) RecordContainerCPUUtilizationDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricContainerCPUUtilization.recordDataPoint(mb.startTime, ts, val)
}

// RecordContainerFilesystemAvailableDataPoint adds a data point to container.filesystem.available metric.
func (mb *MetricsBuilder) RecordContainerFilesystemAvailableDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricContainerFilesystemAvailable.recordDataPoint(mb.startTime, ts, val)
}

// RecordContainerFilesystemCapacityDataPoint adds a data point to container.filesystem.capacity metric.
func (mb *MetricsBuilder) RecordContainerFilesystemCapacityDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricContainerFilesystemCapacity.recordDataPoint(mb.startTime, ts, val)
}

// RecordContainerFilesystemUsageDataPoint adds a data point to container.filesystem.usage metric.
func (mb *MetricsBuilder) RecordContainerFilesystemUsageDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricContainerFilesystemUsage.recordDataPoint(mb.startTime, ts, val)
}

// RecordContainerMemoryAvailableDataPoint adds a data point to container.memory.available metric.
func (mb *MetricsBuilder) RecordContainerMemoryAvailableDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricContainerMemoryAvailable.recordDataPoint(mb.startTime, ts, val)
}

// RecordContainerMemoryMajorPageFaultsDataPoint adds a data point to container.memory.major_page_faults metric.
func (mb *MetricsBuilder) RecordContainerMemoryMajorPageFaultsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricContainerMemoryMajorPageFaults.recordDataPoint(mb.startTime, ts, val)
}

// RecordContainerMemoryPageFaultsDataPoint adds a data point to container.memory.page_faults metric.
func (mb *MetricsBuilder) RecordContainerMemoryPageFaultsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricContainerMemoryPageFaults.recordDataPoint(mb.startTime, ts, val)
}

// RecordContainerMemoryRssDataPoint adds a data point to container.memory.rss metric.
func (mb *MetricsBuilder) RecordContainerMemoryRssDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricContainerMemoryRss.recordDataPoint(mb.startTime, ts, val)
}

// RecordContainerMemoryUsageDataPoint adds a data point to container.memory.usage metric.
func (mb *MetricsBuilder) RecordContainerMemoryUsageDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricContainerMemoryUsage.recordDataPoint(mb.startTime, ts, val)
}

// RecordContainerMemoryWorkingSetDataPoint adds a data point to container.memory.working_set metric.
func (mb *MetricsBuilder) RecordContainerMemoryWorkingSetDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricContainerMemoryWorkingSet.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sNodeCPUTimeDataPoint adds a data point to k8s.node.cpu.time metric.
func (mb *MetricsBuilder) RecordK8sNodeCPUTimeDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricK8sNodeCPUTime.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sNodeCPUUtilizationDataPoint adds a data point to k8s.node.cpu.utilization metric.
func (mb *MetricsBuilder) RecordK8sNodeCPUUtilizationDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricK8sNodeCPUUtilization.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sNodeFilesystemAvailableDataPoint adds a data point to k8s.node.filesystem.available metric.
func (mb *MetricsBuilder) RecordK8sNodeFilesystemAvailableDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sNodeFilesystemAvailable.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sNodeFilesystemCapacityDataPoint adds a data point to k8s.node.filesystem.capacity metric.
func (mb *MetricsBuilder) RecordK8sNodeFilesystemCapacityDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sNodeFilesystemCapacity.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sNodeFilesystemUsageDataPoint adds a data point to k8s.node.filesystem.usage metric.
func (mb *MetricsBuilder) RecordK8sNodeFilesystemUsageDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sNodeFilesystemUsage.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sNodeMemoryAvailableDataPoint adds a data point to k8s.node.memory.available metric.
func (mb *MetricsBuilder) RecordK8sNodeMemoryAvailableDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sNodeMemoryAvailable.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sNodeMemoryMajorPageFaultsDataPoint adds a data point to k8s.node.memory.major_page_faults metric.
func (mb *MetricsBuilder) RecordK8sNodeMemoryMajorPageFaultsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sNodeMemoryMajorPageFaults.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sNodeMemoryPageFaultsDataPoint adds a data point to k8s.node.memory.page_faults metric.
func (mb *MetricsBuilder) RecordK8sNodeMemoryPageFaultsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sNodeMemoryPageFaults.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sNodeMemoryRssDataPoint adds a data point to k8s.node.memory.rss metric.
func (mb *MetricsBuilder) RecordK8sNodeMemoryRssDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sNodeMemoryRss.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sNodeMemoryUsageDataPoint adds a data point to k8s.node.memory.usage metric.
func (mb *MetricsBuilder) RecordK8sNodeMemoryUsageDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sNodeMemoryUsage.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sNodeMemoryWorkingSetDataPoint adds a data point to k8s.node.memory.working_set metric.
func (mb *MetricsBuilder) RecordK8sNodeMemoryWorkingSetDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sNodeMemoryWorkingSet.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sNodeNetworkErrorsDataPoint adds a data point to k8s.node.network.errors metric.
func (mb *MetricsBuilder) RecordK8sNodeNetworkErrorsDataPoint(ts pcommon.Timestamp, val int64, interfaceAttributeValue string, directionAttributeValue AttributeDirection) {
	mb.metricK8sNodeNetworkErrors.recordDataPoint(mb.startTime, ts, val, interfaceAttributeValue, directionAttributeValue.String())
}

// RecordK8sNodeNetworkIoDataPoint adds a data point to k8s.node.network.io metric.
func (mb *MetricsBuilder) RecordK8sNodeNetworkIoDataPoint(ts pcommon.Timestamp, val int64, interfaceAttributeValue string, directionAttributeValue AttributeDirection) {
	mb.metricK8sNodeNetworkIo.recordDataPoint(mb.startTime, ts, val, interfaceAttributeValue, directionAttributeValue.String())
}

// RecordK8sPodCPUTimeDataPoint adds a data point to k8s.pod.cpu.time metric.
func (mb *MetricsBuilder) RecordK8sPodCPUTimeDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricK8sPodCPUTime.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sPodCPUUtilizationDataPoint adds a data point to k8s.pod.cpu.utilization metric.
func (mb *MetricsBuilder) RecordK8sPodCPUUtilizationDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricK8sPodCPUUtilization.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sPodFilesystemAvailableDataPoint adds a data point to k8s.pod.filesystem.available metric.
func (mb *MetricsBuilder) RecordK8sPodFilesystemAvailableDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sPodFilesystemAvailable.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sPodFilesystemCapacityDataPoint adds a data point to k8s.pod.filesystem.capacity metric.
func (mb *MetricsBuilder) RecordK8sPodFilesystemCapacityDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sPodFilesystemCapacity.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sPodFilesystemUsageDataPoint adds a data point to k8s.pod.filesystem.usage metric.
func (mb *MetricsBuilder) RecordK8sPodFilesystemUsageDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sPodFilesystemUsage.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sPodMemoryAvailableDataPoint adds a data point to k8s.pod.memory.available metric.
func (mb *MetricsBuilder) RecordK8sPodMemoryAvailableDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sPodMemoryAvailable.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sPodMemoryMajorPageFaultsDataPoint adds a data point to k8s.pod.memory.major_page_faults metric.
func (mb *MetricsBuilder) RecordK8sPodMemoryMajorPageFaultsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sPodMemoryMajorPageFaults.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sPodMemoryPageFaultsDataPoint adds a data point to k8s.pod.memory.page_faults metric.
func (mb *MetricsBuilder) RecordK8sPodMemoryPageFaultsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sPodMemoryPageFaults.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sPodMemoryRssDataPoint adds a data point to k8s.pod.memory.rss metric.
func (mb *MetricsBuilder) RecordK8sPodMemoryRssDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sPodMemoryRss.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sPodMemoryUsageDataPoint adds a data point to k8s.pod.memory.usage metric.
func (mb *MetricsBuilder) RecordK8sPodMemoryUsageDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sPodMemoryUsage.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sPodMemoryWorkingSetDataPoint adds a data point to k8s.pod.memory.working_set metric.
func (mb *MetricsBuilder) RecordK8sPodMemoryWorkingSetDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sPodMemoryWorkingSet.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sPodNetworkErrorsDataPoint adds a data point to k8s.pod.network.errors metric.
func (mb *MetricsBuilder) RecordK8sPodNetworkErrorsDataPoint(ts pcommon.Timestamp, val int64, interfaceAttributeValue string, directionAttributeValue AttributeDirection) {
	mb.metricK8sPodNetworkErrors.recordDataPoint(mb.startTime, ts, val, interfaceAttributeValue, directionAttributeValue.String())
}

// RecordK8sPodNetworkIoDataPoint adds a data point to k8s.pod.network.io metric.
func (mb *MetricsBuilder) RecordK8sPodNetworkIoDataPoint(ts pcommon.Timestamp, val int64, interfaceAttributeValue string, directionAttributeValue AttributeDirection) {
	mb.metricK8sPodNetworkIo.recordDataPoint(mb.startTime, ts, val, interfaceAttributeValue, directionAttributeValue.String())
}

// RecordK8sVolumeAvailableDataPoint adds a data point to k8s.volume.available metric.
func (mb *MetricsBuilder) RecordK8sVolumeAvailableDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sVolumeAvailable.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sVolumeCapacityDataPoint adds a data point to k8s.volume.capacity metric.
func (mb *MetricsBuilder) RecordK8sVolumeCapacityDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sVolumeCapacity.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sVolumeInodesDataPoint adds a data point to k8s.volume.inodes metric.
func (mb *MetricsBuilder) RecordK8sVolumeInodesDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sVolumeInodes.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sVolumeInodesFreeDataPoint adds a data point to k8s.volume.inodes.free metric.
func (mb *MetricsBuilder) RecordK8sVolumeInodesFreeDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sVolumeInodesFree.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sVolumeInodesUsedDataPoint adds a data point to k8s.volume.inodes.used metric.
func (mb *MetricsBuilder) RecordK8sVolumeInodesUsedDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sVolumeInodesUsed.recordDataPoint(mb.startTime, ts, val)
}

// Reset resets metrics builder to its initial state. It should be used when external metrics source is restarted,
// and metrics builder should update its startTime and reset it's internal state accordingly.
func (mb *MetricsBuilder) Reset(options ...metricBuilderOption) {
	mb.startTime = pcommon.NewTimestampFromTime(time.Now())
	for _, op := range options {
		op(mb)
	}
}
